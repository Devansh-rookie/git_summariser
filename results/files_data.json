{".DS_Store": null, "CppProperties.json": "{\n  \"configurations\": [\n    {\n      \"inheritEnvironments\": [\n        \"msvc_x64\"\n      ],\n      \"name\": \"x64-Release\",\n      \"includePath\": [\n        \"${env.INCLUDE}\",\n        \"${workspaceRoot}\\\\**\"\n      ],\n      \"defines\": [\n        \"WIN32\",\n        \"NDEBUG\",\n        \"UNICODE\",\n        \"_UNICODE\"\n      ],\n      \"intelliSenseMode\": \"windows-msvc-x64\"\n    }\n  ]\n}", "abc.c": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    pid_t pid = fork();\n    // pid_t pid2 = fork();\n    printf(\"pid : %d\\n\",pid);\n    // printf(\"pid2 : %d\\n\",pid2);\n    if (pid < 0) {\n        // Fork failed\n        perror(\"fork\");\n        exit(1);\n    } else if (pid == 0) {\n        // Child process\n        printf(\"Child process: PID = %d\\n\", getpid());\n\n        // Execute a new program\n        char *args[] = {\"ls\", \"-l\", NULL};\n        execvp(args[0], args);\n\n        // If execvp returns, it must have failed\n        perror(\"execvp\");\n        exit(1);\n    } else {\n        // Parent process\n        printf(\"Parent process: PID = %d, Child PID = %d\\n\", getpid(), pid);\n\n        // Wait for the child to complete\n        int status;\n        // waitpid(pid, &status, 0);\n\n        if (WIFEXITED(status)) {\n            printf(\"Child exited with status %d\\n\", WEXITSTATUS(status));\n        }\n        printf(\"Done\");\n    }\n\n    return 0;\n}\n", "answerops2.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\n\nint main() {\n    int n; \n    setIO(\"check\");\n    cin >> n;\n    vector<string> names(n); \n    vector<double> handsomeness(n), intelligence(n), richness(n); \n\n    for (int i = 0; i < n; ++i) {\n        cin >> names[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        cin >> handsomeness[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        cin >> intelligence[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        cin >> richness[i];\n    }\n\n    double maxScore = -1.0;\n    string bestGuy;\n\n    for (int i = 0; i < n; ++i) {\n        double totalScore = handsomeness[i] + intelligence[i] + richness[i];\n        if (totalScore > maxScore) {\n            maxScore = totalScore;\n            bestGuy = names[i];\n        }\n    }\n\n    cout << bestGuy << endl;\n\n    return 0;\n}\n", "bit_inversions.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    string s;\n    int m = 0;\n    cin >> s;\n    int n = s.length();\n    cin >> m;\n    vector<int> changes(m, 0);\n\n    for(int i = 0;i < m;i++) cin >> changes[i];\n\n    \n\n    return 0;\n}", "check.in": "10 9\n8 9\n7 8\n2 3\n9 10\n1 2\n4 5\n3 4\n5 6\n6 7\n", "check.out": "9 2\n8 3\n7 3\n6 4\n5 4\n4 4\n3 5\n2 6\n1 10\n", "question.cpp": "// #include<bits/stdc++.h>\n// using namespace std;\n// using vi = vector<int>;\n// using vvi = vector<vector<int>>;\n// using pii = pair<int, int>;\n\n// void setIO(string name = \"\") {\n//     ios_base::sync_with_stdio(0);\n//     cin.tie(0);\n//     if (name.size()) {\n//         freopen((name + \".in\").c_str(), \"r\", stdin);\n//         freopen((name + \".out\").c_str(), \"w\", stdout);\n//     }\n// }\n\n// vector<pii> changes = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\n// bool check(int i, int j, int n){\n//     return !(i >= n || j>= n|| i< 0 || j < 0);\n// }\n\n// void dfs(int i, int j,vvi & grid, vvi &visited){\n//     int n = grid.size();\n//     visited[i][j] = 1;\n//     for(auto const&[xv, xy] : changes){\n//         int nx = xv + i;\n//         int ny = xy + j;\n\n//         if(check(nx, ny, n) && !visited[nx][ny] && grid[nx][ny] == 1){\n//             dfs(nx, ny, grid, visited);\n//         }\n//     }\n// }\n\n// int solve(vvi &grid1, vvi&grid2){\n//     int n = grid1.size();\n\n//     for(int i = 0;i < n;i++){\n//         for(int j = 0;j < n;j++){\n\n//         }\n//     }\n// }\n\n// int main() {\n//     setIO();\n\n\n\n//     return 0;\n// }\n\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint rows, cols;\n\nvector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nvoid dfs(vector<vector<int>> &grid, int x, int y, set<pair<int, int>> &region, int baseX, int baseY) {\n    if (x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0)\n        return;\n\n    grid[x][y] = 0;\n\n    region.insert({x - baseX, y - baseY});\n\n    for (auto &[dx, dy] : directions) {\n        dfs(grid, x + dx, y + dy, region, baseX, baseY);\n    }\n}\n\nvector<set<pair<int, int>>> findRegions(vector<vector<int>> &grid) {\n    vector<set<pair<int, int>>> regions;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n                set<pair<int, int>> region;\n                dfs(grid, i, j, region, i, j);\n                regions.push_back(region);\n            }\n        }\n    }\n    return regions;\n}\n\nint countMatchingRegions(vector<vector<int>> grid1, vector<vector<int>> grid2) {\n    auto regions1 = findRegions(grid1);\n    auto regions2 = findRegions(grid2);\n\n    int matches = 0;\n    for (auto &r1 : regions1) {\n        for (auto &r2 : regions2) {\n            if (r1 == r2) {  \n                matches++;\n                break; \n            }\n        }\n    }\n    return matches;\n}\n\n// Driver Code\nint main() {\n    vector<vector<int>> grid1 = {\n        {1, 1, 1},\n        {1, 0, 0},\n        {1, 0, 0}\n    };\n\n    vector<vector<int>> grid2 = {\n        {1, 1, 1},\n        {1, 0, 0},\n        {1, 0, 1}\n    };\n\n    rows = grid1.size();\n    cols = grid1[0].size();\n\n    cout << \"Matching Regions: \" << countMatchingRegions(grid1, grid2) << endl;\n    return 0;\n}"}