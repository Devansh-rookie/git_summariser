{
  "Ball.py": "import cv2 # type: ignore\r\nimport random\r\n\r\nfrom utils.constants import SPEED_INCREMENT,BALL_RADIUS,BALL_VEL,BALL_COLOR\r\n\r\nclass Ball:\r\n    def __init__(self, x, y):\r\n        self.x = self.original_x = x\r\n        self.y = self.original_y = y\r\n        self.radius = BALL_RADIUS\r\n        self.vel = BALL_VEL\r\n        self.color = BALL_COLOR\r\n        self.x_vel = BALL_VEL\r\n        self.y_vel = -1*BALL_VEL\r\n\r\n    def draw(self, frame):\r\n        cv2.circle(frame, (int(self.x), int(self.y)),\r\n                   self.radius,self.color, -1)\r\n\r\n    def move(self,frame):\r\n        self.x += self.x_vel\r\n        self.y += self.y_vel\r\n\r\n        self.draw(frame)\r\n    \r\n    def increase_speed(self):\r\n        self.x_vel *= SPEED_INCREMENT\r\n        self.y_vel *= SPEED_INCREMENT\r\n\r\n    def reset(self):\r\n        self.x = self.original_x\r\n        self.y = self.original_y\r\n\r\n        # Randmoize direction at every reset\r\n        choice = random.random()\r\n        x_dir = 1 if choice < 0.5 else -1\r\n        choice = random.random()\r\n        y_dir = 1 if choice < 0.5 else -1\r\n\r\n        self.x_vel = x_dir * self.vel \r\n        self.y_vel = y_dir * self.vel ",
  "Paddle.py": "import cv2 #type: ignore\nfrom utils.constants import HEIGHT,PADDLE_HEIGHT,PADDLE_WIDTH\n\nclass Paddle:\n    def __init__(self, x, y,color):\n        self.x = x\n        self.y = y\n        self.width = PADDLE_WIDTH\n        self.height = PADDLE_HEIGHT\n        self.color = color\n\n    def draw(self, frame):\n        cv2.rectangle(\n            frame,\n            (int(self.x - self.width // 2), int(self.y - self.height // 2)),\n            (int(self.x + self.width // 2), int(self.y + self.height // 2)),\n            self.color,\n            -1,\n        )\n\n    def move(self, x, y):\n        self.x = x\n        self.y = y\n\n        # Ensure the paddle stays within the frame boundaries\n        if self.y - self.height//2 <= 0:\n            self.y = self.height//2\n        if self.y + self.height//2 >= HEIGHT:\n            self.y = HEIGHT - self.height//2\n        \n\n    # def reset(self):\n    #     self.x = self. original_x\n    #     self.y = self.original_y",
  "README.md": "# virtual-air-hockey",
  "Score.py": "import cv2 # type: ignore\nfrom utils.constants import LEFT_OFFSET,RIGHT_OFFSET,WIDTH,MAX_SCORE\n\n\nclass Score:\n    def __init__(self):\n        self.player_a = 0\n        self.player_b = 0\n        self.winner = \"\"\n        pass\n\n    def isWinner(self):\n        if(self.player_a>=MAX_SCORE):\n            self.winner = \"A\"\n            return True\n        elif(self.player_b>=MAX_SCORE):\n            self.winner = \"B\"\n            return True\n        else:\n            return False\n        \n    def calculate_score(self, ball):\n        if ball.x - ball.radius < LEFT_OFFSET:\n            self.player_b += 1\n        elif ball.x + ball.radius > RIGHT_OFFSET:\n            self.player_a += 1\n        pass\n\n    def reset(self):\n        self.player_a = 0\n        self.player_b = 0\n        self.winner = \"\"\n\n    def show(self, ball, frame):\n        self.calculate_score(ball)\n        \n        if(not self.isWinner()):\n            cv2.putText(\n                frame,\n                f\"Player A: {self.player_a}\",\n                (WIDTH//7, 30),\n                cv2.FONT_HERSHEY_SIMPLEX,\n                1,\n                (255, 255, 255),\n                2,\n            )\n            cv2.putText(\n                frame,\n                f\"Player B: { self.player_b}\",\n                (WIDTH*4//7, 30),\n                cv2.FONT_HERSHEY_SIMPLEX,\n                1,\n                (255, 255, 255),\n                2,\n            )\n        else:\n            cv2.putText(\n                frame,\n                f\"Winner is Player: {self.winner}!!!\",\n                (WIDTH*2//7, 30),\n                cv2.FONT_HERSHEY_SIMPLEX,\n                1,\n                (0, 255, 0),\n                2,\n            )\n\n            cv2.imshow(\"Hand Gesture Slider\", frame)\n            cv2.waitKey(5000)\n            self.reset()\n            \n\n    pass",
  "collision.py": "from utils.constants import HEIGHT, LEFT_OFFSET, RIGHT_OFFSET\n\n\ndef handle_collision(ball, left_paddle, right_paddle, frame):\n    # Collision with side edges\n    if ball.x - ball.radius < LEFT_OFFSET or ball.x + ball.radius > RIGHT_OFFSET:\n        ball.reset()\n\n    # Collision with top edge\n    if ball.y - ball.radius <= 0:\n        ball.y_vel = -ball.y_vel\n\n    # Collision with bottom edge\n    if ball.y + ball.radius >= HEIGHT:\n        ball.y_vel = -ball.y_vel\n\n    # Collision with the right slider\n    if ball.x + ball.radius >= right_paddle.x - right_paddle.width // 2 and (\n        ball.y + ball.radius >= right_paddle.y - right_paddle.height // 2 \n        and ball.y - ball.radius <= right_paddle.y + right_paddle.height // 2\n    ):\n        ball.x_vel = -ball.x_vel\n\n        ball.increase_speed()\n\n    # Collision with left slider\n    if ball.x - ball.radius <= left_paddle.x + left_paddle.width // 2 and (\n        ball.y + ball.radius >= left_paddle.y - left_paddle.height // 2\n        and ball.y - ball.radius <= left_paddle.y + left_paddle.height // 2\n    ):\n        ball.x_vel = -ball.x_vel\n\n        ball.increase_speed()\n\n    ball.move(frame)\n",
  "constants.py": "# Window size\r\nWIDTH, HEIGHT = 700, 500\r\n\r\n# Ball Variables\r\nBALL_RADIUS = 15\r\nBALL_COLOR = (255,255,255)\r\nBALL_VEL = 2\r\n\r\n# PADDLE VARIABLES\r\nPADDLE_WIDTH, PADDLE_HEIGHT = 20, 100\r\n\r\n# PADDING\r\nLEFT_OFFSET = PADDLE_WIDTH\r\nRIGHT_OFFSET = WIDTH - LEFT_OFFSET\r\n\r\n# speed increment factor\r\nSPEED_INCREMENT = 1.25\r\n\r\n# Score to min\r\nMAX_SCORE = 5",
  "hand_detection.py": "import cv2 # type: ignore\nimport numpy as np # type: ignore\n\ndef empty(a):\n    pass\n\nclass HandDetection():\n    def __init__(self):\n        pass\n\n    def create_trackbars(self):\n        cv2.namedWindow('Trackbars')\n        cv2.resizeWindow('Trackbars', 500, 300)\n        cv2.createTrackbar('HueMin', 'Trackbars', 0, 179, empty)\n        cv2.createTrackbar('HueMax', 'Trackbars', 179, 179, empty)\n        cv2.createTrackbar('SatMin', 'Trackbars', 0, 255, empty)\n        cv2.createTrackbar('SatMax', 'Trackbars', 255, 255, empty)\n        cv2.createTrackbar('ValMin', 'Trackbars', 0, 255, empty)\n        cv2.createTrackbar('ValMax', 'Trackbars', 60, 255, empty)\n    \n    def create_mask(self, img):\n        imgHSV = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n        hue_min = cv2.getTrackbarPos('HueMin', 'Trackbars')\n        hue_max = cv2.getTrackbarPos('HueMax', 'Trackbars')\n        sat_min = cv2.getTrackbarPos('SatMin', 'Trackbars')\n        sat_max = cv2.getTrackbarPos('SatMax', 'Trackbars')\n        val_min = cv2.getTrackbarPos('ValMin', 'Trackbars')\n        val_max = cv2.getTrackbarPos('ValMax', 'Trackbars')\n        lower = np.array([hue_min, sat_min, val_min])\n        upper = np.array([hue_max, sat_max, val_max])\n        mask = cv2.inRange(imgHSV, lower, upper)\n        return mask\n    \n    def threshold(self, mask):\n        _, thresh_img = cv2.threshold(mask, 127, 255, cv2.THRESH_OTSU)\n        return thresh_img\n    \n    def find_contours(self, thresh_img):\n        contours, _ = cv2.findContours(thresh_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        return contours\n    \n    def two_largest_contours(self, contours):\n        if len(contours) < 2:\n            return contours  # Return all contours if fewer than 2 exist\n        sorted_contours = sorted(contours, key=lambda x: cv2.contourArea(x), reverse=True)[:2]\n        approx_contours = []\n        for cnt in sorted_contours:\n            epsilon = 0.005 * cv2.arcLength(cnt, True)\n            approx = cv2.approxPolyDP(cnt, epsilon, True)\n            approx_contours.append(approx)\n        return approx_contours\n\n    def clean_image(self, mask):\n        img_eroded = cv2.erode(mask, (3, 3), iterations=1)\n        img_dilated = cv2.dilate(img_eroded, (3, 3), iterations=1)\n        return img_dilated\n\n    def centroid(self, contour):\n        if len(contour) == 0:\n            return (-1, -1)\n        M = cv2.moments(contour)\n        try:\n            x = int(M['m10'] / M['m00'])\n            y = int(M['m01'] / M['m00'])\n        except ZeroDivisionError:\n            return (-1, -1)\n        return (x, y)\n    \n    def get_centroid(self,frame):\n        mask = self.create_mask(frame)\n        clean_mask = self.clean_image(mask)\n        thresh_img = self.threshold(clean_mask)\n        contours = self.find_contours(thresh_img)\n        largest_contours = self.two_largest_contours(contours)\n        centroids = []\n        for contour in largest_contours:\n            cx, cy = self.centroid(contour)\n            centroids.append((cx, cy))\n            cv2.drawContours(frame, [contour], -1, (0, 255, 0), 2)\n            cv2.circle(frame, (cx, cy), 5, (0, 0, 255), -1)\n        return centroids\n        \n\n################# DRIVER CODE ###################\n\n# hd = HandDetection()\n# hd.create_trackbars()\n\n# cap = cv2.VideoCapture(0)\n\n# while True:\n#     ret, frame = cap.read()\n#     if not ret:\n#         break\n\n#     mask = hd.create_mask(frame)\n#     clean_mask = hd.clean_image(mask)\n#     thresh_img = hd.threshold(clean_mask)\n#     contours = hd.find_contours(thresh_img)\n#     largest_contours = hd.two_largest_contours(contours)\n\n#     for contour in largest_contours:\n#         cx, cy = hd.centroid(contour)\n#         cv2.drawContours(frame, [contour], -1, (0, 255, 0), 2)\n#         cv2.circle(frame, (cx, cy), 5, (255, 0, 0), -1)\n\n#     cv2.imshow(\"Frame\", frame)\n#     if cv2.waitKey(1) & 0xFF == ord('q'):\n#         break\n\n# cap.release()\n# cv2.destroyAllWindows()\n",
  "main.py": "import cv2 # type: ignore\r\nfrom utils.hand_detection import HandDetection\r\nfrom utils.Ball import Ball\r\nfrom utils.Paddle import Paddle\r\nfrom utils.collision import handle_collision\r\nfrom utils.constants import WIDTH, HEIGHT, LEFT_OFFSET, RIGHT_OFFSET\r\nfrom utils.Score import Score\r\n\r\n# Initialize video capture\r\nvid = cv2.VideoCapture(0)\r\n\r\n# Create an instance of HandDetection\r\nhand_detection = HandDetection()\r\nhand_detection.create_trackbars()\r\n\r\n# Create an instance of Score\r\nscore = Score()\r\n\r\n\r\ndef main():\r\n    left_paddle = Paddle(LEFT_OFFSET, HEIGHT // 2, (255, 0, 0))\r\n    right_paddle = Paddle(RIGHT_OFFSET, HEIGHT // 2, (0, 255, 0))\r\n    ball = Ball(WIDTH // 2, HEIGHT // 2)\r\n\r\n    while vid.isOpened():\r\n        ret, frame = vid.read()\r\n        if not ret:\r\n            break\r\n\r\n        # Resize to defined size\r\n        frame = cv2.resize(frame, (WIDTH, HEIGHT))\r\n\r\n        # Flip the frame for\r\n        frame = cv2.flip(frame, 1)\r\n\r\n        # Get Centroids of hands/color\r\n        centroids = hand_detection.get_centroid(frame)\r\n\r\n        # Assign centroids to paddles\r\n        if len(centroids) == 1:\r\n            left_paddle.move(left_paddle.x, centroids[0][1])\r\n        elif len(centroids) == 2:\r\n            # Sort by x-coordinate\r\n            centroids = sorted(centroids, key=lambda c: c[0])\r\n            left_paddle.move(left_paddle.x, centroids[0][1])\r\n            right_paddle.move(right_paddle.x, centroids[1][1])\r\n        \r\n        # Draw paddles\r\n        left_paddle.draw(frame)\r\n        right_paddle.draw(frame)\r\n\r\n        # Start move ball\r\n        ball.move(frame)\r\n\r\n        # Display score on frame\r\n        score.show(ball, frame)\r\n\r\n        # Handle collision between ball and paddles\r\n        handle_collision(ball, left_paddle, right_paddle, frame)\r\n\r\n        cv2.imshow(\"Hand Gesture Slider\", frame)\r\n\r\n        # Exit\r\n        key = cv2.waitKey(10)\r\n        if key == ord(\"q\"):\r\n            break\r\n\r\n    # Release the video capture and close all OpenCV windows\r\n    vid.release()\r\n    cv2.destroyAllWindows()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n"
}
