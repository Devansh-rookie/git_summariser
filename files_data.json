{
  ".DS_Store": null,
  ".vs/CSES/FileContentIndex/946da5d7-dab9-403c-bf4b-8a1b74487fdd.vsidx": null,
  ".vs/CSES/v17/.wsuo": null,
  ".vs/CSES/v17/DocumentLayout.json": "{\n  \"Version\": 1,\n  \"WorkspaceRootPath\": \"F:\\\\CodingFolder(dont_move)\\\\CSES\\\\\",\n  \"Documents\": [\n    {\n      \"AbsoluteMoniker\": \"D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\\u003CMiscFiles\\u003E|F:\\\\CodingFolder(dont_move)\\\\CSES\\\\problem_sets\\\\WeirdAlgorithm.cpp||{D0E1A5C6-B359-4E41-9B60-3365922C2A22}\",\n      \"RelativeMoniker\": \"D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\\u003CMiscFiles\\u003E|solutionrelative:problem_sets\\\\WeirdAlgorithm.cpp||{D0E1A5C6-B359-4E41-9B60-3365922C2A22}\"\n    },\n    {\n      \"AbsoluteMoniker\": \"D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\\u003CMiscFiles\\u003E|F:\\\\CodingFolder(dont_move)\\\\CSES\\\\CppProperties.json||{90A6B3A7-C1A3-4009-A288-E2FF89E96FA0}\",\n      \"RelativeMoniker\": \"D:0:0:{A2FE74E1-B743-11D0-AE1A-00A0C90FFFC3}|\\u003CMiscFiles\\u003E|solutionrelative:CppProperties.json||{90A6B3A7-C1A3-4009-A288-E2FF89E96FA0}\"\n    }\n  ],\n  \"DocumentGroupContainers\": [\n    {\n      \"Orientation\": 0,\n      \"VerticalTabListWidth\": 256,\n      \"DocumentGroups\": [\n        {\n          \"DockedWidth\": 200,\n          \"SelectedChildIndex\": 1,\n          \"Children\": [\n            {\n              \"$type\": \"Document\",\n              \"DocumentIndex\": 1,\n              \"Title\": \"CppProperties.json\",\n              \"DocumentMoniker\": \"F:\\\\CodingFolder(dont_move)\\\\CSES\\\\CppProperties.json\",\n              \"RelativeDocumentMoniker\": \"CppProperties.json\",\n              \"ToolTip\": \"F:\\\\CodingFolder(dont_move)\\\\CSES\\\\CppProperties.json\",\n              \"RelativeToolTip\": \"CppProperties.json\",\n              \"ViewState\": \"AQIAAAAAAAAAAAAAAAAAABQAAAABAAAA\",\n              \"Icon\": \"ae27a6b0-e345-4288-96df-5eaf394ee369.001642|\",\n              \"WhenOpened\": \"2024-12-22T22:33:36.022Z\",\n              \"EditorCaption\": \"\"\n            },\n            {\n              \"$type\": \"Document\",\n              \"DocumentIndex\": 0,\n              \"Title\": \"WeirdAlgorithm.cpp\",\n              \"DocumentMoniker\": \"F:\\\\CodingFolder(dont_move)\\\\CSES\\\\problem_sets\\\\WeirdAlgorithm.cpp\",\n              \"RelativeDocumentMoniker\": \"problem_sets\\\\WeirdAlgorithm.cpp\",\n              \"ToolTip\": \"F:\\\\CodingFolder(dont_move)\\\\CSES\\\\problem_sets\\\\WeirdAlgorithm.cpp\",\n              \"RelativeToolTip\": \"problem_sets\\\\WeirdAlgorithm.cpp\",\n              \"ViewState\": \"AQIAAAAAAAAAAAAAAAAAABMAAAANAAAA\",\n              \"Icon\": \"ae27a6b0-e345-4288-96df-5eaf394ee369.000677|\",\n              \"WhenOpened\": \"2024-12-22T22:31:52.701Z\",\n              \"EditorCaption\": \"\"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}",
  ".vs/ProjectSettings.json": "{\n  \"CurrentProjectSetting\": \"x64-Release\"\n}",
  ".vs/VSWorkspaceState.json": "{\n  \"ExpandedNodes\": [\n    \"\",\n    \"\\\\problem_sets\"\n  ],\n  \"SelectedNode\": \"\\\\problem_sets\\\\WeirdAlgorithm.cpp\",\n  \"PreviewInSolutionExplorer\": false\n}",
  ".vscode/c_cpp_properties.json": "{\n    \"configurations\": [\n        {\n            \"name\": \"Win32\",\n            \"includePath\": [\n                \"${workspaceFolder}/**\"\n            ],\n            \"defines\": [\n                \"_DEBUG\",\n                \"UNICODE\",\n                \"_UNICODE\"\n            ],\n            \"windowsSdkVersion\": \"10.0.22621.0\",\n            \"compilerPath\": \"C:/MinGW/bin/g++.exe\",\n            \"cStandard\": \"c17\",\n            \"cppStandard\": \"c++20\",\n            \"intelliSenseMode\": \"windows-msvc-x64\"\n        }\n    ],\n    \"version\": 4\n}",
  ".vscode/settings.json": "{\n    \"files.associations\": {\n        \"iostream\": \"cpp\",\n        \"ostream\": \"cpp\",\n        \"random\": \"cpp\",\n        \"stdexcept\": \"cpp\",\n        \"utility\": \"cpp\",\n        \"vector\": \"cpp\",\n        \"algorithm\": \"cpp\",\n        \"unordered_set\": \"cpp\",\n        \"unordered_map\": \"cpp\",\n        \"any\": \"cpp\",\n        \"array\": \"cpp\",\n        \"atomic\": \"cpp\",\n        \"barrier\": \"cpp\",\n        \"bit\": \"cpp\",\n        \"*.tcc\": \"cpp\",\n        \"bitset\": \"cpp\",\n        \"cctype\": \"cpp\",\n        \"cfenv\": \"cpp\",\n        \"charconv\": \"cpp\",\n        \"chrono\": \"cpp\",\n        \"cinttypes\": \"cpp\",\n        \"clocale\": \"cpp\",\n        \"cmath\": \"cpp\",\n        \"codecvt\": \"cpp\",\n        \"compare\": \"cpp\",\n        \"complex\": \"cpp\",\n        \"concepts\": \"cpp\",\n        \"condition_variable\": \"cpp\",\n        \"coroutine\": \"cpp\",\n        \"csetjmp\": \"cpp\",\n        \"csignal\": \"cpp\",\n        \"cstdarg\": \"cpp\",\n        \"cstddef\": \"cpp\",\n        \"cstdint\": \"cpp\",\n        \"cstdio\": \"cpp\",\n        \"cstdlib\": \"cpp\",\n        \"cstring\": \"cpp\",\n        \"ctime\": \"cpp\",\n        \"cuchar\": \"cpp\",\n        \"cwchar\": \"cpp\",\n        \"cwctype\": \"cpp\",\n        \"deque\": \"cpp\",\n        \"forward_list\": \"cpp\",\n        \"list\": \"cpp\",\n        \"map\": \"cpp\",\n        \"set\": \"cpp\",\n        \"string\": \"cpp\",\n        \"exception\": \"cpp\",\n        \"expected\": \"cpp\",\n        \"functional\": \"cpp\",\n        \"iterator\": \"cpp\",\n        \"memory\": \"cpp\",\n        \"memory_resource\": \"cpp\",\n        \"numeric\": \"cpp\",\n        \"optional\": \"cpp\",\n        \"ratio\": \"cpp\",\n        \"regex\": \"cpp\",\n        \"source_location\": \"cpp\",\n        \"string_view\": \"cpp\",\n        \"system_error\": \"cpp\",\n        \"tuple\": \"cpp\",\n        \"type_traits\": \"cpp\",\n        \"format\": \"cpp\",\n        \"fstream\": \"cpp\",\n        \"future\": \"cpp\",\n        \"initializer_list\": \"cpp\",\n        \"iomanip\": \"cpp\",\n        \"iosfwd\": \"cpp\",\n        \"istream\": \"cpp\",\n        \"latch\": \"cpp\",\n        \"limits\": \"cpp\",\n        \"mutex\": \"cpp\",\n        \"new\": \"cpp\",\n        \"numbers\": \"cpp\",\n        \"ranges\": \"cpp\",\n        \"scoped_allocator\": \"cpp\",\n        \"semaphore\": \"cpp\",\n        \"shared_mutex\": \"cpp\",\n        \"span\": \"cpp\",\n        \"spanstream\": \"cpp\",\n        \"sstream\": \"cpp\",\n        \"stacktrace\": \"cpp\",\n        \"stdfloat\": \"cpp\",\n        \"stop_token\": \"cpp\",\n        \"streambuf\": \"cpp\",\n        \"syncstream\": \"cpp\",\n        \"thread\": \"cpp\",\n        \"typeindex\": \"cpp\",\n        \"typeinfo\": \"cpp\",\n        \"valarray\": \"cpp\",\n        \"variant\": \"cpp\",\n        \"ios\": \"cpp\",\n        \"__bit_reference\": \"cpp\",\n        \"__config\": \"cpp\",\n        \"__hash_table\": \"cpp\",\n        \"__locale\": \"cpp\",\n        \"__node_handle\": \"cpp\",\n        \"__split_buffer\": \"cpp\",\n        \"__threading_support\": \"cpp\",\n        \"__tree\": \"cpp\",\n        \"__verbose_abort\": \"cpp\",\n        \"execution\": \"cpp\",\n        \"locale\": \"cpp\",\n        \"queue\": \"cpp\",\n        \"stack\": \"cpp\"\n    },\n    \"C_Cpp.errorSquiggles\": \"enabledIfIncludesResolve\"\n}",
  "994/1.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int t;\n    cin >> t;\n\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> arr(n);\n        for(int i=0;i < n;i++){\n            cin >> arr[i];\n        }\n        bool notzero = false;\n        for(int i= 0;i < n;i++){\n            if(arr[i]){\n                notzero = true;\n            }\n        }\n        if(!notzero){\n            cout << \"0\" <<\"\\n\";\n            continue;\n        }\n\n        int left =0;\n        int right = n-1;\n        while(left < n && !arr[left]){\n            left++;\n        }\n        while(right >= 0 && !arr[right]){\n            right--;\n        }\n\n        for(int i = left;i <= right; i++){\n            if(!arr[i]){\n                cout << \"1\" << \"\\n\";\n                continue;\n            }\n        }\n        cout << \"2\" <<\"\\n\";\n    }\n    return 0;\n}",
  "994/2.cpp": "// #include <iostream>\n// #include <fstream>\n// #include <sstream>\n// #include <iomanip>\n// #include <string>  \n// #include <vector>\n// #include <list>        \n// #include <set> \n// #include <map>    \n// #include <queue> \n// #include <stack>\n// #include <algorithm>  \n// #include <cmath> \n// #include <ctime> \n// #include <cstdlib>\n// #include <cstring> \n// #include <cctype> \n// #include <cassert>\n// #include <exception>   \n// #include <functional>\n// #include <iterator>\n// #include <limits>  \n// #include <locale>   \n// #include <numeric>  \n// #include <random> \n// #include <stdexcept> \n// #include <typeinfo> \n// #include <utility>\n// using namespace std;\n// int main()\n// {\n//     int t;\n//     cin >> t;\n\n//     while(t--){\n//         string s;\n//         int n;\n//         cin >> n;\n//         cin >> s;\n//         s = \".\" + s;\n//         if(s[1] == 'p' && s[n] == 's'){\n//             cout << \"NO\" << \"\\n\";\n//         }\n//         string p = \"\";\n//         string ss = \"\";\n//         string dot = \"\";\n//         for(int i=0;i < n;i++){\n//             p += 'p';\n//             ss += 's';\n//             dot += '.';\n//         }\n//         if(p == s || s == ss || dot == s){\n//             cout << \"YES\";\n//             continue;\n//         }\n\n\n//     }\n//     return 0;\n// }\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool is_valid_permutation(const string &s) {\n    int n = s.size();\n    vector<bool> prefix_valid(n + 1, true);\n    vector<bool> suffix_valid(n + 1, true);\n    \n    // Check prefix validity\n    unordered_set<int> seen;\n    for (int i = 1; i <= n; ++i) {\n        if (s[i - 1] == 's') break;\n        seen.insert(i);\n        if ((int)seen.size() != i) {\n            prefix_valid[i] = false;\n            break;\n        }\n    }\n\n    // Check suffix validity\n    seen.clear();\n    for (int i = n; i >= 1; --i) {\n        if (s[i - 1] == 'p') break;\n        seen.insert(n - i + 1);\n        if ((int)seen.size() != n - i + 1) {\n            suffix_valid[i] = false;\n            break;\n        }\n    }\n\n    // Check all constraints\n    for (int i = 1; i <= n; ++i) {\n        if (s[i - 1] == 'p' && !prefix_valid[i]) return false;\n        if (s[i - 1] == 's' && !suffix_valid[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        string s;\n        cin >> s;\n        if (is_valid_permutation(s)) {\n            cout << \"YES\\n\";\n        } else {\n            cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}\n",
  "994/3.cpp": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint calculateMex(const unordered_set<int>& values) {\n    int mex = 0;\n    while (values.find(mex) != values.end()) {\n        ++mex;\n    }\n    return mex;\n}\n\nvoid solve() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, x, y;\n        cin >> n >> x >> y;\n        vector<vector<int>> adj(n + 1);\n        for(int i = 1; i <= n; ++i){\n            adj[i].push_back(i == 1 ? n : i - 1);\n            adj[i].push_back(i == n ? 1 : i + 1); \n        }\n        adj[x].push_back(y); \n        adj[y].push_back(x);\n\n        vector<int> result(n + 1, -1);\n        for(int i = 1; i <= n; ++i){\n            unordered_set<int> neighborValues;\n            for(int neighbor : adj[i]) {\n                if(result[neighbor] != -1){\n                    neighborValues.insert(result[neighbor]);\n                }\n            }\n            result[i] = calculateMex(neighborValues);\n        }\n        for(int i = 1; i <= n; ++i){\n            cout << result[i] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    solve();\n    return 0;\n}\n",
  "995/1.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\n\n\nint main()\n{\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        vector<int> b(n);\n\n        for(int i=0;i < n;i++){\n            cin >> a[i];\n        }\n        for(int i=0;i < n;i++){\n            cin >> b[i];\n        }\n        if(n == 1){\n            cout << a[0] << endl;\n            continue;\n        }\n        int ans = 0;\n        for(int i=0;i < n;i++){\n            if(i + 1 < n && a[i] > b[i+1]){\n                ans += a[i] - b[i+1];\n            }\n        }\n        ans += a[n-1];\n        cout << ans << endl;\n    }\n    return 0;\n}",
  "995/1.py": "def maximize_difference(n, a, b, i=0, m=0, s=0):\n    # Base case: no more days to consider\n    if i >= n:\n        return m - s\n\n    # Option 1: Monocarp skips this day\n    skip = maximize_difference(n, a, b, i + 1, m, s)\n    \n    # Option 2: Monocarp trains on this day\n    stereocarp_contrib = b[i + 1] if i + 1 < n else 0\n    train = maximize_difference(n, a, b, i + 2, m + a[i], s + stereocarp_contrib)\n    \n    # Return the maximum of the two options\n    return max(skip, train)\n\n# Process multiple test cases\ndef solve():\n    t = int(input())  # Number of test cases\n    results = []\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        b = list(map(int, input().split()))\n        # Compute the result for the current test case\n        results.append(maximize_difference(n, a, b))\n    \n    # Print all results\n    for res in results:\n        print(res)\n\n# Example Input/Output\n# Uncomment below lines to run locally\nsolve()\n",
  "995/2.cpp": "// #include <iostream>\n// #include <fstream>\n// #include <sstream>\n// #include <iomanip>\n// #include <string>  \n// #include <vector>\n// #include <list>        \n// #include <set> \n// #include <map>    \n// #include <queue> \n// #include <stack>\n// #include <algorithm>  \n// #include <cmath> \n// #include <ctime> \n// #include <cstdlib>\n// #include <cstring> \n// #include <cctype> \n// #include <cassert>\n// #include <exception>   \n// #include <functional>\n// #include <iterator>\n// #include <limits>  \n// #include <locale>   \n// #include <numeric>  \n// #include <random> \n// #include <stdexcept> \n// #include <typeinfo> \n// #include <utility>\n// using namespace std;\n// int main()\n// {\n//     int t;\n//     cin >> t;\n//     while(t--){\n//         long n, a, b, c;\n//         cin >> n >> a >> b >> c;\n\n//         int val = n/(a+b+c);\n\n//         long some = (n-1)*(a+b+c);\n//         if(a+some >= n){\n//             cout << val*3 + 1 << endl;\n//             continue;\n//         }\n//         some += a;\n//         if(b+some >= n){\n//             cout << val*3 + 2 << endl;\n//             continue;\n//         }\n//         some += b;\n//         if(c+some >= n){\n//             cout << val*3 + 3 << endl;\n//             continue;\n//         }\n//         cout << \"-1\";\n//     }\n//     return 0;\n// }\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        long long n, a, b, c;\n        cin >> n >> a >> b >> c;\n\n        long long cycle_sum = a + b + c;\n        long long full_cycles = n / cycle_sum;\n        long long distance_covered = full_cycles * cycle_sum;\n\n        long long days = full_cycles * 3;\n\n        long long remaining = n - distance_covered;\n\n        if (remaining > 0) {\n            if (remaining <= a) {\n                days += 1;\n            } else if (remaining <= a + b) {\n                days += 2;\n            } else {\n                days += 3;\n            }\n        }\n\n        cout << days << endl;\n    }\n\n    return 0;\n}\n",
  "995/3.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\n#include <unordered_set>\nusing namespace std;\nint main()\n{\n    int t;\n    cin >> t;\n    while(t--){\n        int n, m , k;\n        cin >> n >> m >> k;\n        \n        vector<int> missing(m);\n        for(int i=0;i < m;i++){\n            cin >> missing[i];\n        }\n\n        set<int> kk;\n        int doesnk =n+1;\n        for(int i=0;i < k;i++){\n            int val;\n            cin >> val;\n            kk.insert(val);\n        }\n\n        if(n == k){\n            for(int i=0;i < m;i++){\n                cout << 1;\n            }\n            cout << '\\n';\n            continue;\n        }\n\n        if(k <= n-2){\n            for(int i=0;i < m;i++){\n                cout << 0;\n            }\n            cout << '\\n';\n            continue;\n        }\n\n        for(int i=1;i <= n;i++){\n            if(kk.find(i) == kk.end()){\n                doesnk = i;\n                break;\n            }\n        }\n\n        for(int i=0;i < m;i++){\n            if(doesnk == missing[i]){\n                cout << 1;\n            }\n            else cout << 0;\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n// #include <iostream>\n// #include <vector>\n// #include <unordered_set>\n// #include<set>\n// using namespace std;\n\n// int main() {\n//     int t;\n//     cin >> t;\n\n//     while(t--){\n//         int n, m, k;\n//         cin >> n >> m >> k;\n\n//         vector<int> missing(m);\n//         for(int i = 0; i < m; ++i){\n//             cin >> missing[i];\n//         }\n\n//         // unordered_set<int> known_questions;\n//         // for(int i = 0; i < k; ++i){\n//         //     int q;\n//         //     cin >> q;\n//         //     known_questions.insert(q);\n//         // }\n\n//         vector<int> known_questions(k);\n\n//         for(int i = 0; i < k; ++i){\n//             cin >> known_questions[i];\n//         }\n\n//         set<int> some(known_questions.begin(), known_questions.end());\n\n//         for(int i=1;i <= n;i++){\n//             if\n//         }\n\n//         string result(m, '0');\n//         for(int i = 0; i < m; ++i){\n//             int skipped = missing[i]; \n//             bool can_pass = true;\n\n//             for(int j = 1; j <= n; ++j){\n//                 if (j != skipped && known_questions.find(j) == known_questions.end()) {\n//                     can_pass = false;\n//                     break;\n//                 }\n//             }\n\n//             if(can_pass){\n//                 result[i] = '1';\n//             }\n//         }\n\n//         cout << result << '\\n';\n//     }\n\n//     return 0;\n// }\n",
  "995/4.cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        long long x, y;\n        cin >> n >> x >> y;\n\n        vector<int> a(n);\n        long long total_sum = 0;\n\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i];\n            total_sum += a[i];\n        }\n\n        // Initialize the count of interesting pairs\n        long long interesting_pairs = 0;\n\n        // Sort the array for efficient two-pointer calculation\n        sort(a.begin(), a.end());\n\n        for (int i = 0; i < n; ++i) {\n            long long remaining_sum = total_sum - a[i];\n            long long lb = x - remaining_sum;\n            long long ub = y - remaining_sum;\n\n            // Use binary search to count valid pairs\n            long long start = *lower_bound(a.begin() + i + 1, a.end(), lb);\n            long long  end = *upper_bound(a.begin() + i + 1, a.end(), ub);\n\n            interesting_pairs += end - start;\n        }\n\n        cout << interesting_pairs << '\\n';\n    }\n\n    return 0;\n}\n",
  "995/4.py": "from bisect import bisect_left, bisect_right\n\ndef count_interesting_pairs(t, test_cases):\n    results = []\n    for case in test_cases:\n        n, x, y, a = case\n        S = sum(a)\n        L, R = S - y, S - x\n        a.sort()\n        count = 0\n        \n        for i in range(n):\n            low = L - a[i]\n            high = R - a[i]\n            j_left = bisect_left(a, low, i + 1)\n            j_right = bisect_right(a, high, i + 1)\n            count += j_right - j_left\n        \n        results.append(count)\n    \n    return results\n\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, x, y = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, x, y, a))\n\nresults = count_interesting_pairs(t, test_cases)\nprint(\"\\n\".join(map(str, results)))\n",
  "995/5.cpp": "// #include <iostream>\n// #include <fstream>\n// #include <sstream>\n// #include <iomanip>\n// #include <string>  \n// #include <vector>\n// #include <list>        \n// #include <set> \n// #include <map>    \n// #include <queue> \n// #include <stack>\n// #include <algorithm>  \n// #include <cmath> \n// #include <ctime> \n// #include <cstdlib>\n// #include <cstring> \n// #include <cctype> \n// #include <cassert>\n// #include <exception>   \n// #include <functional>\n// #include <iterator>\n// #include <limits>  \n// #include <locale>   \n// #include <numeric>  \n// #include <random> \n// #include <stdexcept> \n// #include <typeinfo> \n// #include <utility>\n// using namespace std;\n// int main()\n// {\n//     int t;\n//     cin >> t;\n//     while(t--){\n//         int n, k;\n//         cin >> n >> k;\n//         vector<int>a(n);\n//         vector<int>b(n);\n//         for(int i=0;i < n;i++) cin >> a[i];\n//         for(int i=0;i < n;i++) cin >> b[i];\n\n\n//     }\n//     return 0;\n// }\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to determine if a given price can fit in at least `n-k` intervals\nbool canKeepPrice(const vector<pair<int, int>>& intervals, int price, int needed) {\n    int count = 0;\n    for (const auto& interval : intervals) {\n        if (interval.first <= price && price <= interval.second) {\n            count++;\n        }\n        if (count >= needed) return true; // Early termination\n    }\n    return count >= needed;\n}\n\nvoid solve() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, k;\n        cin >> n >> k;\n\n        vector<pair<int, int>> intervals(n);\n        vector<int> allPrices;\n\n        for (int i = 0; i < n; i++) {\n            cin >> intervals[i].first; // a[i]\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> intervals[i].second; // b[i]\n        }\n\n        // Collect all unique interval endpoints for binary search\n        for (const auto& interval : intervals) {\n            allPrices.push_back(interval.first);\n            allPrices.push_back(interval.second);\n        }\n\n        // Sort the intervals and unique prices\n        sort(intervals.begin(), intervals.end());\n        sort(allPrices.begin(), allPrices.end());\n        allPrices.erase(unique(allPrices.begin(), allPrices.end()), allPrices.end());\n\n        int needed = n - k; // Minimum intervals where price must be valid\n        int maxPrice = 0;\n\n        // Binary search over all unique prices\n        int left = 0, right = allPrices.size() - 1;\n        while (left <= right) {\n            int midIndex = (left + right) / 2;\n            int candidatePrice = allPrices[midIndex];\n\n            if (canKeepPrice(intervals, candidatePrice, needed)) {\n                maxPrice = candidatePrice;\n                left = midIndex + 1; // Try for a higher price\n            } else {\n                right = midIndex - 1; // Reduce the price range\n            }\n        }\n\n        cout << maxPrice << endl;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n    return 0;\n}\n",
  "998/1.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n\n    int t;\n\n    cin >> t;\n\n    while(t--){\n        vector<int> arr(4, 0);\n\n        for(int i = 0;i < 4;i++) cin >> arr[i];\n\n        int val1 = arr[0] + arr[1];\n        int val2 = arr[3] - arr[2];\n        int val3 = arr[2] - arr[1];\n\n        int ans = 1;\n\n        if(val1 == val3 && val1 == val2){\n            ans = 3;\n        }\n\n        else if(val1 == val2 || val2 == val3 || val1 == val3){\n            ans = 2;\n        }\n\n        cout << ans<< '\\n';\n    }\n\n    return 0;\n}",
  "998/2.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n    int t;\n    cin >> t;\n    while(t--){\n        outer:\n        if(t<0) break;\n        int n,m;\n        cin >> n >> m;\n\n        vector<vector<int>> cards(n, vector<int> (m, 0));\n\n        for(int i =0;i < n;i++){\n            for(int j = 0;j < m;j++){\n                cin >> cards[i][j];\n            }\n        }\n\n        for(int i =0;i < n;i++){\n            sort(cards[i].begin(), cards[i].end());\n        }\n\n        vector<int> p(n, 0);\n        vector<pair<int, int>> temp;\n\n        for(int i = 0;i < n;i++){\n            temp.emplace_back(cards[i][0], i);\n        }\n\n        sort(temp.begin(), temp.end());\n\n        for(int i = 0;i < n;i++){\n            p[i] = temp[i].second;\n        }\n\n        // bool flag = true;\n        int maxx = 0;\n        for(int j = 0;j < m;j++){\n            vector<pair<int, int>> ti;\n            for(int i = 0;i < n;i++){\n                ti.emplace_back(cards[i][j], i);\n            }\n            sort(ti.begin(), ti.end());\n            if(maxx > ti[0].first){\n                cout << \"-1\\n\";\n                t--;\n                goto outer;\n            }\n            for(int i = 0;i < n;i++){\n                if(ti[i].second != p[i]){\n                    cout << \"-1\\n\";\n                    t--;\n                    goto outer;\n                }\n            }\n            maxx = max(ti[n-1].first, maxx);\n        }\n\n        for(int i : p){\n            cout << i + 1 <<' ';\n        }\n\n        cout << '\\n';\n    }\n\n    return 0;\n}\n",
  "998/3.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nvoid solve(){\n    int t;\n    cin >> t;\n    while(t--){\n        int n, k;\n        cin >> n >> k;\n        vector<int> x(n);\n        map<int, int> m;\n        for(int i = 0; i < n;i++){\n            cin >> x[i];\n            m[x[i]]++;\n        }\n\n        int ans = 0;\n        for(const auto&[num, count]:m){\n            int opp = k - num;\n            if(m.count(opp)){\n                if(opp == num){\n                    ans += m[num]/2;\n                } \n                else if(m[num] > 0 && m[opp] > 0){\n                    int pairs = min(m[num], m[opp]);\n                    ans += pairs;\n                    m[num] -= pairs;\n                    m[opp] -= pairs;\n                }\n            }\n        }\n        cout << ans << '\\n';\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n    solve();\n    return 0;\n}",
  "998/4.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nstring solve(){\n    int n;\n    cin >> n;\n    vector<int> arr(n, 0);\n\n    for(int i = 0;i < n;i++) cin >> arr[i];\n\n    if(arr[0] > arr[1]) return \"NO\";\n\n    for(int i = 1;i < n - 1;i++){\n        // if(arr[i] > arr[i+1]){\n        //     int val = min(arr[i], arr[i-1]);\n        //     arr[i] = arr[i] - val;\n        //     arr[i-1] = arr[i-1] - val;\n        //     if(arr[i+1] < arr[i]) return \"NO\";\n        //     if(i >= 2 && arr[i - 1] < arr[i-2]){\n        //         return \"NO\";\n        //     }\n        // }\n        int val = min(arr[i], arr[i-1]);\n        arr[i] = arr[i] - val;\n        arr[i-1] = arr[i-1] - val;\n    }\n\n    for(int i = 0;i < n-1;i++){\n        if(arr[i] > arr[i+1]) return \"NO\";\n    }\n\n    return \"YES\";\n}\n\nint main() {\n    // setIO(\"check\");\n\n    int t;\n    \n    cin >> t;\n\n    while(t--){\n        cout << solve() << endl;\n    }\n\n    return 0;\n}",
  "998/5.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nvoid solve(){\n    int n, m1 ,m2;\n    cin >> n >> m1 >> m2;\n\n    // F first then G\n\n    vector<set<int>> f(n+1);\n    vector<set<int>> g(n+1);\n    vector<set<int>> dg(n+1);\n\n    for(int i = 0;i < m1;i++){\n        int u, v;\n        cin >> u >> v;\n        f[v].insert(u);\n        f[u].insert(v);\n    }\n    for(int i = 0;i < m2;i++){\n        int u, v;\n        cin >> u >> v;\n        g[v].insert(u);\n        g[u].insert(v);\n        dg[u].insert(v);\n    }\n\n    long long ans = 0;\n\n    for(int i = 1;i <= n;i++){\n        set<int> del;\n        for(int nei : f[i]){\n            if(g[i].find(nei) == g[i].end()){\n                ans++;\n                // f[i].erase(nei);\n                del.insert(nei);\n                f[nei].erase(i);\n            }\n        }\n        for(int j : del){\n            f[i].erase(j);\n        }\n    }\n\n    int add = 0;\n\n    for(int i = 1;i <= n;i++){\n        for(int nei : g[i]){\n            add += (long long)(g[i].size() - f[i].size());\n        }\n    }\n\n    cout << ans + add/2<< endl;\n}\n\nint main() {\n    setIO(\"check\");\n\n    int t;\n    cin >> t;\n\n    while(t--) solve();\n\n    return 0;\n}\n",
  "998/check.in": "5\n3 2 1\n1 2\n2 3\n1 3\n2 1 1\n1 2\n1 2\n3 2 0\n3 2\n1 2\n1 0 0\n3 3 1\n1 2\n1 3\n2 3\n1 2\n",
  "998/check.out": "2\n0\n3\n0\n2\n",
  "CppProperties.json": "{\n  \"configurations\": [\n    {\n      \"inheritEnvironments\": [\n        \"msvc_x64\"\n      ],\n      \"name\": \"x64-Release\",\n      \"includePath\": [\n        \"${env.INCLUDE}\",\n        \"${workspaceRoot}\\\\**\"\n      ],\n      \"defines\": [\n        \"WIN32\",\n        \"NDEBUG\",\n        \"UNICODE\",\n        \"_UNICODE\"\n      ],\n      \"intelliSenseMode\": \"windows-msvc-x64\"\n    }\n  ]\n}",
  "Introduction/bit_strings.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\n\n\n#define MOD 1000000007\n\n\nusing namespace std;\n\nlong long myPow(long x, int n) {\n    if(x==0) return 0.0;\n    else if(n==0||x==1) return 1.0;\n    long long a= myPow(x,n/2);\n    if(n%2==0){\n        return (long long)a*a%(long long)MOD;\n    }\n    else{\n        if(n>0) return (long long)x*a*a%(long long)MOD;\n        else return (((long long)(a*a)%(long long)MOD)/(long long)x)%(long long)MOD;\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    cout << myPow(2, n) <<endl;\n    return 0;\n}",
  "Introduction/chess_queen.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    \n    return 0;\n}",
  "Introduction/coin_piles.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int t;\n    cin >> t;\n    while(t--){\n        long a, b;\n        cin >> a >> b;\n\n        if(a == b){\n            cout << \"YES\" << endl;\n            continue;\n        }\n        else if(a == b-1 || a-1 == b){\n            cout << \"YES\" << endl;\n        }\n        else{\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
  "Introduction/creating_strings.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid solve(vector<int>&ch, string ansnode, unordered_set<string> &check, int n){\n    int len = ansnode.length();\n    if(len == n && check.find(ansnode) == check.end()){\n        for(char c: ansnode){\n            cout << c;\n        }\n        cout << endl;\n        check.insert(ansnode);\n        ansnode.clear();\n        return;\n    }\n\n    for(int i=0;i < 26;i++){\n        if(ch[i]){\n            // ch[i]--;\n            ansnode += ((char)i + 'a');\n            ch[i]--;\n            solve(ch, ansnode, check, n);\n            // ch[i]++;\n            ansnode.pop_back();\n            ch[i]++;\n        }\n    }\n}\n\nlong fac(int n, vector<int> &dp){\n    if(n<=1) return 1;\n    if(dp[n] != -1) return dp[n];\n    return dp[n] = n*fac(n-1, dp);\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    string s;\n\n    cin >> s;\n    int n = s.length();\n    vector<int> ch(26, 0);\n    unordered_set<string> check;\n    for(char c: s){\n        ch[c - 'a']++;\n    }\n    vector<int> dp(n+1, -1);\n    int ans = fac(n, dp);\n    for(int i=0;i < 26;i++){\n        if(ch[i]){\n            ans /= fac(ch[i], dp);\n        }\n    }\n    cout << ans << endl;\n    solve(ch, \"\", check, n);\n\n    return 0;\n}",
  "Introduction/digit_queries.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    \n    return 0;\n}",
  "Introduction/gray_code.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid decToBinary(int n, int maxx)\n{\n    // Size of an integer is assumed to be 32 bits\n    for (int i = maxx; i >= 0; i--) {\n        int k = n >> i;\n        if (k & 1)\n            cout << \"1\";\n        else\n            cout << \"0\";\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    // og num then n>>1 and take XOR for n\n    // 100110\n    // 010011\n\n    // 110101\n\n    int n;\n    cin >> n;\n    long long maxx = pow(2, n);\n    for(int i=0;i < maxx;i++){\n        long long newnum = (i)^(i>>1);\n        decToBinary(newnum, n-1);\n        cout << endl;\n    }\n    return 0;\n}",
  "Introduction/grid_paths.cpp": "// // // #include <iostream>\n// // // #include <fstream>\n// // // #include <sstream>\n// // // #include <iomanip>\n// // // #include <string>  \n// // // #include <vector>\n// // // #include <list>        \n// // // #include <set> \n// // // #include <map>    \n// // // #include <queue> \n// // // #include <stack>\n// // // #include <algorithm>  \n// // // #include <cmath> \n// // // #include <ctime> \n// // // #include <cstdlib>\n// // // #include <cstring> \n// // // #include <cctype> \n// // // #include <cassert>\n// // // #include <exception>   \n// // // #include <functional>\n// // // #include <iterator>\n// // // #include <limits>  \n// // // #include <locale>   \n// // // #include <numeric>  \n// // // #include <random> \n// // // #include <stdexcept> \n// // // #include <typeinfo> \n// // // #include <utility>\n// // // using namespace std;\n// // // int n;\n// // // int dx[] = {1, -1, 0, 0};\n// // // int dy[] = {0, 0, -1, 1};\n// // // char moveChar[] = {'D', 'U', 'L', 'R'};\n// // // bool isValid(int x, int y, vector<vector<bool>> &vis) {\n// // //     return x >= 0 && x < n && y >= 0 && y < n && !vis[x][y];\n// // // }\n\n// // // int solve(int i, int j, string &s, int index, vector<vector<vector<int>>> &dp, vector<vector<bool>> &vis){\n// // //     int N = n;\n// // //     int x = i;\n// // //     int y = j;\n// // //     // if(i == n - 1 && j == 0 && index == 48){\n// // //     //     return 1;\n// // //     // }\n// // //     // if(i >= n || j >= n || j <0 || i < 0 || index == 48|| vis[i][j]) return 0;\n// // //     if (index == 48) {\n// // //         return (x == N - 1 && y == 0) ? 1 : 0;\n// // //     }\n\n// // //     // If already reached the target but not at the last step, prune\n// // //     if (x == N - 1 && y == 0) {\n// // //         return 0;\n// // //     }\n\n// // //      if ((x > 0 && vis[x - 1][y]) + (x < N - 1 && vis[x + 1][y]) +\n// // //         (y > 0 && vis[x][y - 1]) + (y < N - 1 && vis[x][y + 1]) == 4) {\n// // //         return 0;\n// // //     }\n// // //     if(dp[i][j][index]!= -1) return dp[i][j][index];\n// // //     vis[i][j] = true;\n// // //     int ans = 0;\n// // //     if(s[index] != '?'){\n// // //         // if(s[index] == 'D'){\n// // //         //     int nx = i + dx[0];\n// // //         //     int ny = j + dy[0];\n// // //         //     if(isValid(nx, ny, vis)) ans += solve(nx, ny, s, index+1, dp, vis);\n// // //         // }\n// // //         // else if(s[index] == 'L'){\n// // //         //     int nx = i + dx[2];\n// // //         //     int ny = j + dy[2];\n// // //         //     if(isValid(nx, ny, vis)) ans += solve(nx, ny,s, index+1, dp, vis);\n// // //         // }\n// // //         // else if(s[index] == 'U'){\n// // //         //     int nx = i + dx[1];\n// // //         //     int ny = j + dy[1];\n// // //         //     if(isValid(nx, ny, vis)) ans += solve(nx, ny, s, index+1, dp, vis);\n// // //         // }\n// // //         // else{ // 'R'\n// // //         //     int nx = i + dx[3];\n// // //         //     int ny = j + dy[3];\n// // //         //     if(isValid(nx, ny, vis)) ans += solve(nx, ny, s, index+1, dp, vis);\n// // //         // }\n// // //         for (int m = 0; m < 4; m++) {\n// // //             if (s[index] == moveChar[m]) {\n// // //                 int nx = i + dx[m], ny = j + dy[m];\n// // //                 if (isValid(nx, ny, vis)) {\n// // //                     ans += solve(nx, ny, s, index+1, dp, vis);\n// // //                 }\n// // //             }\n// // //         }\n\n// // //     }\n// // //     else{\n// // //         // vector<pair<int ,int>> paths = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n// // //         // for(auto node: paths){\n// // //         //     int x = node.first;\n// // //         //     int y = node.second;\n// // //         //     ans += solve(i+x, j+y, s, index+1, dp, vis);\n// // //         // }\n// // //         for (int m = 0; m < 4; m++) {\n// // //             int nx = i + dx[m], ny = j + dy[m];\n// // //             if (isValid(nx, ny, vis)) {\n// // //                 ans += solve(nx, ny, s, index+1, dp, vis);\n// // //             }\n// // //         }\n// // //     }\n// // //     vis[i][j] = false;\n// // //     return dp[i][j][index] = ans;\n// // // }\n\n// // // int main()\n// // // {\n// // //     string s;\n// // //     cin >> s;\n// // //     n = 7;\n\n// // //     vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(48, -1)));\n// // //     vector<vector<bool>> vis(n, vector<bool> (n, false));\n// // //     cout << solve(0, 0, s, 0, dp, vis) << endl;\n// // //     return 0;\n// // // }\n\n\n// // #include <iostream>\n// // #include <vector>\n// // #include <string>\n\n// // using namespace std;\n\n// // const int N = 7; // Grid size\n// // const int STEPS = 48; // Total number of steps\n// // string description; // Input description\n// // bool visited[N][N]; // Visited grid\n\n// // // Moves: Down, Up, Left, Right\n// // int dx[] = {1, -1, 0, 0};\n// // int dy[] = {0, 0, -1, 1};\n// // char moveChar[] = {'D', 'U', 'L', 'R'};\n\n// // bool isValid(int x, int y) {\n// //     return x >= 0 && x < N && y >= 0 && y < N && !visited[x][y];\n// // }\n\n// // int dfs(int x, int y, int step, vector<vector<vector<int>>>&dp) {\n// //     // Base case: reached step limit and at target position\n// //     if (step == STEPS) {\n// //         return (x == N - 1 && y == 0) ? 1 : 0;\n// //     }\n\n// //     // If already reached the target but not at the last step, prune\n// //     if (x == N - 1 && y == 0) {\n// //         return 0;\n// //     }\n\n// //     // Check if surrounded (early pruning)\n// //     if ((x > 0 && visited[x - 1][y]) + (x < N - 1 && visited[x + 1][y]) +\n// //         (y > 0 && visited[x][y - 1]) + (y < N - 1 && visited[x][y + 1]) == 4) {\n// //         return 0;\n// //     }\n// //     // if(dp[x][y][step]!= -1) return dp[x][y][step];\n\n// //     int paths = 0;\n// //     visited[x][y] = true;\n\n// //     if (description[step] == '?') {\n// //         // Try all possible moves\n// //         for (int i = 0; i < 4; i++) {\n// //             int nx = x + dx[i], ny = y + dy[i];\n// //             if (isValid(nx, ny)) {\n// //                 paths += dfs(nx, ny, step + 1, dp);\n// //             }\n// //         }\n// //     } else {\n// //         // Follow the fixed move\n// //         for (int i = 0; i < 4; i++) {\n// //             if (description[step] == moveChar[i]) {\n// //                 int nx = x + dx[i], ny = y + dy[i];\n// //                 if (isValid(nx, ny)) {\n// //                     paths += dfs(nx, ny, step + 1, dp);\n// //                 }\n// //             }\n// //         }\n// //     }\n\n// //     visited[x][y] = false;\n// //     // return dp[x][y][step] = paths;\n// //     return paths;\n// // }\n\n// // int main() {\n// //     cin >> description;\n\n// //     // Initialize the visited grid\n// //     for (int i = 0; i < N; i++) {\n// //         for (int j = 0; j < N; j++) {\n// //             visited[i][j] = false;\n// //         }\n// //     }\n// //     int n = N;\n// //     vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(48, -1)));\n\n// //     // Start DFS from the top-left corner\n\n// //     cout << dfs(0, 0, 0, dp) << endl;\n// //     return 0;\n// // }\n\n\n// #include <iostream>\n// #include <string>\n// #include <cstring>\n\n// using namespace std;\n\n// const int N = 7; // Grid size\n// const int STEPS = 48; // Total number of steps\n// string description; // Input description\n// int dp[N][N][STEPS]; // DP table\n// bool visited[N][N]; // Visited grid\n\n// // Moves: Down, Up, Left, Right\n// int dx[] = {1, -1, 0, 0};\n// int dy[] = {0, 0, -1, 1};\n// char moveChar[] = {'D', 'U', 'L', 'R'};\n\n// bool isValid(int x, int y) {\n//     return x >= 0 && x < N && y >= 0 && y < N && !visited[x][y];\n// }\n\n// int dfs(int x, int y, int step) {\n//     // Base case: reached step limit and at target position\n//     if (step == STEPS) {\n//         return (x == N - 1 && y == 0) ? 1 : 0;\n//     }\n\n//     // If already reached the target but not at the last step, prune\n//     if (x == N - 1 && y == 0) {\n//         return 0;\n//     }\n\n//     // If already calculated, return the result\n//     if (dp[x][y][step] != -1) {\n//         return dp[x][y][step];\n//     }\n\n//     int paths = 0;\n//     visited[x][y] = true;\n\n//     if (description[step] == '?') {\n//         // Try all possible moves\n//         for (int i = 0; i < 4; i++) {\n//             int nx = x + dx[i], ny = y + dy[i];\n//             if (isValid(nx, ny)) {\n//                 paths += dfs(nx, ny, step + 1);\n//             }\n//         }\n//     } else {\n//         // Follow the fixed move\n//         for (int i = 0; i < 4; i++) {\n//             if (description[step] == moveChar[i]) {\n//                 int nx = x + dx[i], ny = y + dy[i];\n//                 if (isValid(nx, ny)) {\n//                     paths += dfs(nx, ny, step + 1);\n//                 }\n//             }\n//         }\n//     }\n\n//     visited[x][y] = false;\n//     return dp[x][y][step] = paths;\n// }\n\n// int main() {\n//     cin >> description;\n\n//     // Initialize DP table and visited grid\n//     memset(dp, -1, sizeof(dp));\n//     memset(visited, false, sizeof(visited));\n\n//     // Start DFS from the top-left corner\n//     cout << dfs(0, 0, 0) << endl;\n\n//     return 0;\n// }\n\n\n#include <iostream>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 7; // Grid size\nconst int STEPS = 48; // Total number of steps\nstring description; // Input description\nint dp[N][N][STEPS]; // DP table\nbool visited[N][N]; // Visited grid\n\n// Moves: Down, Up, Left, Right\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, -1, 1};\nchar moveChar[] = {'D', 'U', 'L', 'R'};\n\nbool isValid(int x, int y) {\n    return x >= 0 && x < N && y >= 0 && y < N && !visited[x][y];\n}\n\nint dfs(int x, int y, int step) {\n    // Base case: reached step limit and at target position\n    if (step == STEPS) {\n        return (x == N - 1 && y == 0) ? 1 : 0;\n    }\n\n    // If already calculated, return the result\n    if (dp[x][y][step] != -1) {\n        return dp[x][y][step];\n    }\n\n    int paths = 0;\n    visited[x][y] = true;\n\n    if (description[step] == '?') {\n        // Try all possible moves\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i], ny = y + dy[i];\n            if (isValid(nx, ny)) {\n                paths += dfs(nx, ny, step + 1);\n            }\n        }\n    } else {\n        // Follow the fixed move\n        for (int i = 0; i < 4; i++) {\n            if (description[step] == moveChar[i]) {\n                int nx = x + dx[i], ny = y + dy[i];\n                if (isValid(nx, ny)) {\n                    paths += dfs(nx, ny, step + 1);\n                }\n            }\n        }\n    }\n\n    visited[x][y] = false;\n    return dp[x][y][step] = paths;\n}\n\nint main() {\n    cin >> description;\n\n    // Initialize DP table and visited grid\n    memset(dp, -1, sizeof(dp));\n    memset(visited, false, sizeof(visited));\n\n    // Start DFS from the top-left corner\n    cout << dfs(0, 0, 0) << endl;\n\n    return 0;\n}\n",
  "Introduction/increasing_array.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for(int i=0;i < n;i++){\n        cin >> arr[i];\n    }\n\n    int val = arr[0];\n    long long ans = 0;\n    for(int i=1;i < n;i++){\n        if(arr[i] < val){\n            ans += val - arr[i];\n            arr[i] = val;\n        }\n        else val = arr[i];\n    }\n    cout << ans << endl;\n   return 0;\n}",
  "Introduction/missing_number.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n;\n    cin >> n;\n    unordered_set<int> s;\n    for(int i=0;i < n-1;i++){\n        int val;\n        cin >> val;\n        s.insert(val);\n    }\n \n    for(int i=1;i <= n;i++){\n        if(s.find(i) == s.end()){\n            cout << i;\n            return 0;\n        }\n    }\n    return 1;\n}\n",
  "Introduction/number_spiral.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    \n    return 0;\n}",
  "Introduction/palindrom_reorder.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    string s;\n\n    cin >> s;\n\n    int n = s.length();\n    vector<int> c(26, 0);\n    for(char ch: s){\n        c[ch-'A']++;\n    }\n\n    if(n%2 == 1){\n        int numb_odd = 0;\n        for(int i=0; i < 26 && numb_odd < 2;i++){\n            if(c[i]%2 == 1) numb_odd++;\n        }\n        if(numb_odd != 1){\n            cout << \"NO SOLUTION\" << endl;\n            return 0;\n        }\n        int odd = 0;\n        for(int i=0;i < 26;i++){\n            if(c[i]%2 == 1) odd = i;\n            for(int j = 0;j < c[i]/2;j++){\n                cout << (char)(i+'A');\n            }\n        }\n        cout << (char)(odd+'A');\n        for(int i=25;i >=0;i--){\n            for(int j = 0;j < c[i]/2;j++){\n                cout << (char)(i+'A');\n            }\n        }\n    }\n    else{\n        int numb_odd = 0;\n        for(int i=0; i < 26 && numb_odd < 2;i++){\n            if(c[i]%2 == 1) numb_odd++;\n        }\n        if(numb_odd){\n            cout << \"NO SOLUTION\" << endl;\n            return 0;\n        }\n        for(int i=0;i < 26;i++){\n            for(int j = 0;j < c[i]/2;j++){\n                cout << (char)(i+'A');\n            }\n        }\n        for(int i=25;i >=0;i--){\n            for(int j = 0;j < c[i]/2;j++){\n                cout << (char)(i+'A');\n            }\n        }\n    }\n\n    return 0;\n}",
  "Introduction/permutations.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    if(n == 1){\n        cout << \"1\"<<endl;\n        return 0;\n    }\n    if(n <= 3){\n        cout <<\"NO SOLUTION\"<<endl;\n        return 0;\n    }\n    // print all odd then all even numbers\n    // as odd numbers and even number have the difference of 2 and never 1 so we just check if the difference between the last odd and the first even has a difference more than 1 or not\n    // for 4 start from n and subtract till 0\n\n    if(n == 4){\n        cout << \"2 4 1 3\"<< endl;\n        return 0;\n    }\n    for(int i=1;i <= n;i+=2){\n        cout << i << \" \";\n    }\n    for(int i = 2;i <= n;i+=2){\n        cout << i << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
  "Introduction/repetitions.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\n    string s;\n    cin >> s;\n    int ans = 1;\n    for(int i=1; i <s.length();i++){\n        int node = 1;\n        while(i < s.length() && s[i] == s[i-1]){\n            node++;\n            i++;\n        }\n        ans = max(ans, node);\n    }\n    cout << ans<< endl;\n   return 0;\n}",
  "Introduction/string_matching.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    string s;\n    string p;\n\n    cin >> s;\n    cin >> p;\n    int n=0, m=0;\n    int ans = 0;\n    for(int i=0;i < n;i++){\n        int j = i;\n        while(j < m && i+j < n && s[i+j] == p[j]){\n            j++;\n        }\n        if(j == m){\n            i = j;\n            ans++;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}",
  "Introduction/tower_of_hanoi.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\n\nvoid toh(int n, char s, char a, char d){\n    if(n == 1){\n        cout << s << \" \" << d << endl;\n    }\n    else{\n        toh(n-1, s, d, a);\n        cout << s << \" \" << d << endl;\n        toh(n-1, a, s, d);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    int n;\n    cin >> n;\n    cout << pow(2, n) - 1 <<endl;\n    toh(n, '1', '2', '3');\n    return 0;\n}",
  "Introduction/trailing_zeros.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int n;\n    cin >> n;\n    int ans = 0;\n    while(n){\n        n /= 5;\n        ans += n;\n    }\n    cout << ans << endl;\n    return 0;\n}",
  "Introduction/two_knights.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int n;\n\n    cin >> n;\n\n    for(int i = 1; i <= n;i++){\n        cout << ((long long)i*i*((long long)i*i - 1))/2 - (long long)4*(i-1)*(i-2) << endl;\n    }\n    return 0;\n}",
  "Introduction/two_set.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> s1, s2;\n    if(n%4 == 0 || n%4 == 3){\n        long long req_sum = (long long)n*(n+1)/4;\n        for(int i = n;i > 0;i--){\n            if(req_sum >= i){\n                req_sum -= i;\n                // cout << i << \" \";\n                s1.push_back(i);\n            }\n            else{\n                // cout << i << \" \";\n                s2.push_back(i);\n            }\n        }\n    }\n    else{\n        cout << \"NO\" << endl;\n        return 0;\n    }\n    cout << \"YES\" << endl;\n    cout << s1.size() << endl;\n    for(int i: s1){\n        cout << i << \" \";\n    }\n    cout << endl;\n    cout << s2.size() << endl;\n    for(int i: s2){\n        cout << i << \" \";\n    }\n    return 0;\n}",
  "Introduction/word_combinations.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nint solve(string &str, vector<string>& arr, int index, string ans, unordered_map<string, int>&dp){\n    int n = arr.size();\n    if(ans.length() > str.length()) return 0;\n    if(ans == str) return 1;\n    if(index == n) return 0;\n    if(dp.find(ans) != dp.end())return dp[ans];\n    int node = 0;\n    for(int i= index;i < n;i++){\n        node += solve(str, arr, i, ans + arr[i], dp);\n    }\n    return dp[ans] = node;\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    string str;\n    cin >> str;\n\n    int k;\n    cin >> k;\n    vector<string> arr;\n    for(int i=0;i < k; i++){\n        string val;\n        cin >> val;\n        arr.push_back(val);\n    }\n\n    // check in how many ways the string can be made using a dp table with unordered_map, string as key\n\n    unordered_map<string, int> dp;\n\n\n    cout << solve(str, arr, 0, \"\", dp) <<endl;\n    return 0;\n}",
  "additional/a.out": null,
  "additional/check.in": "5",
  "additional/check.out": "8",
  "additional/multi_table.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n\n    ll n;\n    cin >> n;\n    // cout << (n - (n/2) + 1)*(n/2);\n\n    // high = n^2 and low = 1;\n\n    ll high = n*n;\n\n    ll low = 1;\n    ll mid;\n    while(low < high){\n        // mid and mid + 1, as it would be a monotonically increasing function\n        // we need the minimum x which is greater than (n*n + 1)/2\n        mid = (low + high)/2;\n        ll how_many_are_less = 0;\n        // go from 1 to n rows and find how many number are smaller than or eqaul to the current mid\n        for(int i = 1;i <= n;i++){\n            // or suma += min(mid/i, n);\n            if(mid >= i*n){\n                how_many_are_less += n;\n            }\n            else{\n                // add the i till which mid is greater than or equal to\n                // i*j = some then j = mid/i; GIF is the thing\n                how_many_are_less += mid/i;\n            }\n        }\n\n        // ____----\n        // this is the type of function so we need to find the breaking point by mid + 1 and bound it by mid from high if it satisfies\n\n        if((n*n + 1)/2 <= how_many_are_less){ // that is basically exact half\n            high = mid;// make it smaller \n        }\n        else low = mid + 1; // make it larger \n    }\n\n    cout << low; // low == high in the end I think??\n\n    return 0;\n}",
  "answerops2.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\n\nint main() {\n    int n; \n    setIO(\"check\");\n    cin >> n;\n    vector<string> names(n); \n    vector<double> handsomeness(n), intelligence(n), richness(n); \n\n    for (int i = 0; i < n; ++i) {\n        cin >> names[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        cin >> handsomeness[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        cin >> intelligence[i];\n    }\n\n    for (int i = 0; i < n; ++i) {\n        cin >> richness[i];\n    }\n\n    double maxScore = -1.0;\n    string bestGuy;\n\n    for (int i = 0; i < n; ++i) {\n        double totalScore = handsomeness[i] + intelligence[i] + richness[i];\n        if (totalScore > maxScore) {\n            maxScore = totalScore;\n            bestGuy = names[i];\n        }\n    }\n\n    cout << bestGuy << endl;\n\n    return 0;\n}\n",
  "bit_inversions.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    string s;\n    int m = 0;\n    cin >> s;\n    int n = s.length();\n    cin >> m;\n    vector<int> changes(m, 0);\n\n    for(int i = 0;i < m;i++) cin >> changes[i];\n\n    \n\n    return 0;\n}",
  "check.in": "4 7\n1 0 1\n0 0 1\n0 2 3\n1 0 1\n1 1 2\n0 0 2\n1 1 3\n",
  "check.out": "0\n1\n0\n1\n",
  "dp/ac_frog_1.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\n// predict future states using the current states\nvoid push_dp(){\n    int n;\n    cin >> n;\n\n    vi arr = vi(n, 0);\n    for(int i =0;i < n;i++) cin>> arr[i];\n    vi dp = vi(n+1, INT_MAX);\n    dp[0] = 0; // base case already on 0\n    for(int i = 0;i < n-1;i++){\n        dp[i+1] = min(dp[i+1], dp[i] + abs(arr[i] - arr[i+1]));\n        if(i + 2 < n) \n            dp[i+2] = min(dp[i+2], dp[i] + abs(arr[i] - arr[i+2]));\n    }\n    cout << dp[n-1];\n}\n\n// predict the current states using the previous states\nvoid pull_dp(){\n    int n;\n    cin >> n;\n\n    vi arr = vi(n, 0);\n\n    for(int i =0;i < n;i++) cin>> arr[i];\n    vi dp = vi(n, 0);\n    for(int i = 1;i < n;i++){\n        dp[i] = min(\n            dp[i-1] + abs(arr[i] - arr[i-1]), \n            (i>=2)?(dp[i-2] + abs(arr[i]- arr[i-2])):INT_MAX\n        );\n    }\n    cout << dp[n-1];\n}\n\nint main() {\n    // setIO(\"check\");\n    push_dp();\n    return 0;\n}",
  "dp/check.in": "3",
  "dp/check.out": "4",
  "dp/dice_comb.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nconst int MOD = (int)(1e9 + 7);\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n    ll n;\n    cin >> n;\n\n    vi dp = vi(n+1, 0);\n\n    dp[0] = 1;\n\n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= 6;j++){\n            if(i - j >= 0){\n                dp[i] = (dp[i] + dp[i - j])%MOD;\n            }\n        }\n    }\n\n    cout << dp[n]%MOD;\n\n    return 0;\n}",
  "dp/increasing_frequency.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing ll = long long;\nusing vl = vector<ll>;\nusing vvl = vector<vl>;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    setIO();\n\n\n\n    return 0;\n}",
  "dp/mortal_combat_tower.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nvoid solve(){\n    int n;\n    cin >> n;\n\n    vi arr = vi(n, 0);\n    for(int i = 0;i < n;i++) cin >> arr[i];\n\n    vvi dp = vvi(n+1, vi(2, 1e8));\n    // here 1 would be my friend and 0 would be me\n\n    // here the next is of 0'th player, if its written dp[0][0] for 0th index 0th player has to play next 1st has played and 0 was the min skips\n    dp[0][0] = 0;\n    for(int i = 0;i < n;i++){\n        // (second val)add the skips to it to get there if we are coming from the friends branch otherwise take it directly(first val)\n        dp[i+1][1] = min(dp[i+1][1], arr[i] + dp[i][0]);\n        if(i + 2 <= n) \n            dp[i+2][1] = min(dp[i+2][1], arr[i+1] + arr[i] + dp[i][0]);\n        // here directly go or come from my branch\n        dp[i+1][0] = min(dp[i+1][0], dp[i][1]);\n        if(i + 2 <= n) dp[i+2][0] = min(dp[i+2][0], dp[i][1]);\n    }\n\n    cout << min(dp[n][0], dp[n][1]) << endl;\n}\n\nint main() {\n    // setIO(\"check\");\n\n    int t;\n    cin >> t;\n\n    while(t--){\n        solve();\n    }\n\n    return 0;\n}",
  "goodbye2024/1.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> arr(n);\n        for(int i=0;i < n;i++) cin >> arr[i];\n\n        // sort(arr.begin(), arr.end());\n\n        // if(arr[0] == arr[n-1]){\n        //     cout << \"YES\\n\";\n        //     continue;\n        // }\n\n        // if(arr[0]*2<= arr[1]){\n        //     cout << \"NO\\n\";\n        // }\n        // else cout << \"YES\\n\";\n        bool possible = false;\n        for(int i=0;i < n-1;i++){\n            if((arr[i] + arr[i+1] > arr[i]) && (arr[i]*2 > arr[i+1])&&(arr[i+1] *2 > arr[i]) && (arr[i]+arr[i+1] > arr[i+1])){\n                possible = true;\n                break;\n            }\n        }\n        if(possible) cout << \"YES\\n\";\n        else cout <<\"NO\\n\";\n    }\n    return 0;\n}",
  "goodbye2024/1.py": "def solve():\n    import sys\n    # input = sys.stdin.read\n    # data = input().splitlines()\n    t = int(input())\n\n    # t = int(data[0])  # Number of test cases\n    results = []\n    idx = 1\n\n    for _ in range(t):\n        n = int(input())  # Number of impressions in this test case\n        idx += 1\n\n        ranges = []\n        for __ in range(n):\n            l, r = map(int, data[idx].split())\n            ranges.append((l, r))\n            idx += 1\n\n        # Initialize frequency array for coordinate compression\n        max_val = 2 * n\n        freq = [0] * (max_val + 2)\n\n        # Process the ranges\n        for l, r in ranges:\n            freq[l] += 1\n            freq[r + 1] -= 1\n\n        # Calculate the prefix sum to get active frequencies\n        active = [0] * (max_val + 1)\n        for i in range(1, max_val + 1):\n            active[i] = active[i - 1] + freq[i]\n\n        # Check uniqueness for each impression\n        result = []\n        for l, r in ranges:\n            unique = False\n            for value in range(l, r + 1):\n                if active[value] == 1:\n                    unique = True\n                    break\n            result.append('1' if unique else '0')\n\n        results.append(''.join(result))\n\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    solve()\n",
  "goodbye2024/2.cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\n// void solve() {\n//     int n;\n//     cin >> n;\n\n//     vector<vector<int>> arr(n, vector<int> (2, 0));\n//     map<int, int> m;\n//     for(int i=0;i < n;i++){\n//         cin >> arr[i][0] >> arr[i][1];\n\n//         if(arr[i][0] == arr[i][1]){\n//             m[arr[i][0]]++;\n//         }\n//     }\n\n//     vector<int> present(2*n + 1, 0);\n//     for (auto &[key, freq] : m) {\n//         if (key <= 2*n) {\n//             present[key] = 1;\n//         }\n//     }\n\n//     vector<int> prefix_present(2*n + 1, 0);\n//     for (int i = 1; i <= 2*n; i++) {\n//         prefix_present[i] = prefix_present[i - 1] + present[i];\n//     }\n\n//     vector<int> ans(n, 1);\n//     for (int i = 0; i < n; i++) {\n//         int a = arr[i][0], b = arr[i][1];\n\n//         // Calculate actual sum using prefix sums\n//         int actual_sum = prefix_present[b] - (a > 1 ? prefix_present[a - 1] : 0);\n\n//         // Calculate expected sum using sum of natural numbers\n//         int expected_sum = ((long long)b * (b + 1)) / 2 - ((long long)(a - 1) * a) / 2;\n\n//         // If actual sum doesn't match expected sum, mark as not unique\n//         if(expected_sum == actual_sum){\n//             ans[i] = 0;\n//         }\n//         if(arr[i][0] == arr[i][1] && m[arr[i][0]] > 1){\n//             ans[i] = 0;\n//         }\n//     }\n\n//     for (int bit : ans) {\n//         cout << bit;\n//     }\n//     cout << endl;\n// }\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> arr(n, vector<int>(2, 0));\n    map<int, int> m;\n    for(int i = 0; i < n; i++){\n        cin >> arr[i][0] >> arr[i][1];\n\n        if(arr[i][0] == arr[i][1]){\n            m[arr[i][0]]++;\n        }\n    }\n\n    vector<int> present(2 * n + 1, 0);\n    for (auto &[key, freq] : m) {\n        if (key <= 2 * n) {\n            present[key] = 1;\n        }\n    }\n\n    vector<int> prefix_present(2 * n + 1, 0);\n    for (int i = 1; i <= 2 * n; i++) {\n        prefix_present[i] = prefix_present[i - 1] + present[i];\n    }\n\n    vector<int> ans(n, 1);\n    for (int i = 0; i < n; i++){\n        int a = arr[i][0], b = arr[i][1];\n        int count_in_range = prefix_present[b] - prefix_present[a - 1];\n        if(arr[i][0] == arr[i][1]){\n            if(m[arr[i][0]] > 1)ans[i] = 0;\n            continue;\n        }\n        if(count_in_range == (b - a + 1)){\n            ans[i] = 0;\n        }\n    }\n\n    for(int bit : ans) {\n        cout << bit;\n    }\n    cout << endl;\n}\n\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n",
  "goodbye2024/3.cpp": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <utility>\nusing namespace std;\n\ntypedef long long ll;\n\nvector<ll> calculateLuckyValue(const vector<pair<ll, ll>>& testCases) {\n    vector<ll> results;\n\n    for (const auto& [n, k] : testCases) {\n        ll luckyValue = 0;\n        stack<pair<ll, ll>> segments;\n        segments.push({1, n}); // Start with the full range\n\n        while (!segments.empty()) {\n            auto [l, r] = segments.top();\n            segments.pop();\n\n            ll length = r - l + 1;\n\n            if (length < k) {\n                continue;\n            }\n\n            ll mid = (l + r) / 2;\n\n            // If the length is odd, add the middle star to lucky value\n            if (length % 2 == 1) {\n                luckyValue += mid;\n                segments.push({l, mid - 1});\n                segments.push({mid + 1, r});\n            } else {\n                segments.push({l, mid});\n                segments.push({mid + 1, r});\n            }\n        }\n\n        results.push_back(luckyValue);\n    }\n\n    return results;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t;\n    cin >> t;\n    vector<pair<ll, ll>> testCases(t);\n\n    for (int i = 0; i < t; ++i) {\n        cin >> testCases[i].first >> testCases[i].second;\n    }\n\n    vector<ll> results = calculateLuckyValue(testCases);\n\n    for (ll result : results) {\n        cout << result << \"\\n\";\n    }\n\n    return 0;\n}\n",
  "goodbye2024/3new.cpp": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll something(ll n,ll k){\n    ll ans = 0;\n            ll l = 1, r = n;\n            ll depth = 0;\n            ll ogMid = (l+r)/2;\n            while (r - l + 1 >= k) {\n                ll mid = (l + r) / 2;\n\n                if ((r - l + 1) % 2 == 1) {\n                    r = mid - 1;\n                    ans += (ll)(ogMid)*pow(2, depth);\n                } else {\n                    r = mid;\n                }\n                depth++;\n            }\n    return ans;\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--){\n        ll n, k;\n        cin >> n >> k;\n        if(k == 1) cout << (ll)n*(n+1)/2 << endl;\n        else if(n%2 == 1){\n            ll ans = 0;\n            ll l = 1, r = n;\n            ll depth = 0;\n            ll ogMid = (l+r)/2;\n            while (r - l + 1 >= k) {\n                ll mid = (l + r) / 2;\n\n                if ((r - l + 1) % 2 == 1) {\n                    r = mid - 1;\n                    ans += (ll)(ogMid)*pow(2, depth);\n                } else {\n                    r = mid;\n                }\n                depth++;\n            }\n            cout << ans << '\\n';\n        }\n        else{\n            ll ans = 0;\n            ll l = 1, r = n;\n            ll depth = 0;\n            ll ogMid = (l+r)/2;\n            while (r - l + 1 >= k && r%2 == 0) {\n                ll mid = (l + r) / 2;\n\n                if ((r - l + 1) % 2 == 1) {\n                    r = mid - 1;\n                    // ans += (ll)(ogMid)*pow(2, depth);\n                } else {\n                    r = mid;\n                }\n                depth++;\n            }\n            ll some = something(r, k);\n            ans = (some + (pow(2, depth)-1)*some);\n            cout << ans << '\\n';\n        }\n    }\n    return 0;\n}",
  "goodbye2024/a.out": null,
  "goodbye2024/extra2.cpp": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nvoid solve() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n\n        vector<pair<int, int>> intervals(n); // Store intervals {l, r}\n        for (int i = 0; i < n; ++i) {\n            cin >> intervals[i].first >> intervals[i].second;\n        }\n\n        map<int, bool> used; // Track used values\n        vector<int> result(n, 0); // Result array\n\n        for (int i = 0; i < n; ++i) {\n            int l = intervals[i].first;\n            int r = intervals[i].second;\n\n            bool found = false;\n            for (int val = l; val <= r; ++val) {\n                if (!used[val]) {\n                    used[val] = true; // Mark the value as used\n                    result[i] = 1;    // Mark the interval as unique\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                result[i] = 0; // No valid value found for this interval\n            }\n        }\n\n        // Output the result for this test case\n        for (int bit : result) {\n            cout << bit;\n        }\n        cout << '\\n';\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    solve();\n\n    return 0;\n}\n",
  "graph/building_teams.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nbool dfs(vector<vector<int>> &graph, int node, vector<int> &color, int col){\n        color[node] = col;\n        bool ans = true;\n        for(int nei : graph[node]){\n            if(color[nei] != -1){\n                if(color[nei] == col){\n                    return false;\n                }\n            }\n            else{\n                ans = dfs(graph, nei, color, !col);\n            }\n        }\n        return ans;\n    }\n\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    // int n = graph.size();\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> graph(n+1);\n    vector<int> color(n+1, -1);\n\n    for(int i = 0;i < m;i++){\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    // bool ans = true;\n    for(int i = 0;i < n;i++) {\n        if(color[i] == -1){\n            bool val = dfs(graph, i, color,0);\n            if(!val){\n                cout << \"IMPOSSIBLE\" << endl;\n                return 0;\n            }    \n        }\n    }\n\n    for(int i = 1;i <= n;i++){\n        cout << color[i] + 1 << ' ';\n    }\n\n    return 0;\n}",
  "graph/buildroads.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pll = pair<ll, ll>;\n\n\nvoid dfs(int node, vector<bool> &vis, vector<vector<ll>>&adj){\n    if(vis[node]) return;\n    vis[node] = true;\n    for(ll nei: adj[node]){\n        dfs(nei, vis, adj);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, m;\n    cin >>n >> m;\n    vector<vector<ll>> adj(n+1);\n\n    for(int i = 0;i < m;i++){\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<pll> ans;\n    vector<bool> vis(n+1, false);\n    dfs(1, vis, adj);\n    for(int i = 1;i <= n;i++){\n        if(!vis[i]){\n            ans.emplace_back(1, i); \n            dfs(i, vis, adj);\n        }\n        // as we have just found a disconnected component we just need to connect it to one of the things it can be any constant or the last value of that dfs search otherise just make a constant c like 1 here which is behaving like a capital, all roads lead to 1 instead of Rome now :smile\n    }\n\n    cout << ans.size() << endl;\n\n    for(pll p: ans){\n        cout << p.first << ' ' << p.second << endl;\n    }\n\n    return 0;\n}",
  "graph/check.in": "5 8\n########\n#..#...#\n####.#.#\n#..#...#\n########",
  "graph/check.out": "3",
  "graph/couting_rooms.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint ans = 0;\nint n, m;\nvector<vector<int>> arr;\nvector<vector<int>> vis;\nvector<pii> paths = {{0, 1},{1, 0},{-1, 0},{0, -1}};\n\n\nbool check(int x, int y){\n    return !(x >= n || y >= m || x < 0 || y < 0);\n}\n\nvoid dfs(int i, int j){\n    vis[i][j] = 1;\n    for(auto const &[cx, cy] : paths){\n        int nx , ny;\n        nx = i + cx;\n        ny = j + cy;\n        if(!check(nx, ny) || vis[nx][ny] || !arr[i][j]) continue;\n        dfs(nx, ny);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n    cin >> n >> m;\n    arr.resize(n, vector<int>(m, 0));\n    vis.resize(n, vector<int>(m, 0));\n\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j < m;j++){\n            char val;\n            cin >> val;\n\n            if(val == '.') arr[i][j] = 1;\n        }\n    }\n\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j < m;j++){\n            if(arr[i][j] && !vis[i][j]){\n                ans++;\n                dfs(i, j);\n            }\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}",
  "graph/flight_routes_check.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>> &adj, vector<bool> &vis){\n    vis[node] = true;\n    for(int i : adj[node]){\n        if(!vis[i]) dfs(i, adj, vis);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, m;\n\n    cin >> n >> m;\n\n    vector<vector<int>> adj(n+1);\n    vector<int> out(n+1, 0);\n    vector<int> in(n+1, 0);\n\n    for(int i =0;i < m;i++){\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        out[u]++;\n        in[v]++;\n    }\n\n    for(int i = 1;i <= n;i++){\n        if(!out[i]){\n            cout << \"NO\\n\";\n            cout << i << ' ' << ((i != 1) ? 1 : i-1) << endl;\n            return 0;\n        }\n        else if(!in[i]){\n            cout << \"NO\\n\";\n            cout << ((i != 1) ? 1 : i-1) << ' ' << i << endl;\n            return 0;\n        }\n    }\n\n\n    // for(int i = 1;i <= n;i++){\n    //     vector<bool> vis(n+1, false);\n    //     dfs(i, adj, vis);\n\n\n    // }\n    int currI = 0;\n    int currVal = INT_MAX;\n\n    for(int i =1;i <= n;i++){\n        if(out[i] <= currVal){\n            currVal = out[i];\n            currI = i;\n        }\n    }\n\n    vector<bool> vis(n+1, false);\n\n    dfs(currI, adj, vis);\n\n    for(int i = 1;i <= n;i++){\n        if(!vis[i]){\n            cout << \"NO\\n\";\n            cout << currI << ' ' << i << '\\n';\n            return 0;\n        }\n    }\n\n    cout << \"YES\\n\";\n\n    return 0;\n}",
  "maths/.DS_Store": null,
  "maths/couting_divisors.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e6;\nint arr[N+1];\nvoid sieve(){\n    for(int i = 2;i <= N;i++){\n        if(!arr[i]){\n            for(int j = i;j <= N;j+=i){\n                arr[j] = i; // largest prime number dividing j then we will check it again and again by dividing\n            }\n        }\n    }\n}\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nlong long some(int x){\n    long long ans = 1;\n    while(x != 1){\n        // max prime first then x would change\n        int max_prime_dividing_x = arr[x];\n        int alpha_i = 0;\n\n        while(x % max_prime_dividing_x == 0){\n            x /= max_prime_dividing_x;\n            alpha_i++;\n        }\n\n        ans *= (alpha_i + 1);\n    }\n    return ans;\n}\n\nint main() {\n    // setIO(\"check\");\n    sieve();\n    int n;\n    cin >> n;\n\n    // for(int j = 0;j < n;j++){\n    //     int x;\n    //     cin >> x;\n    //     long long ans = 0;\n    //     int i = 1;\n    //     for(i = 1;i * i < x;i++){\n    //         if(x%i == 0) ans+=2; // since every factor would have 2 like 3 * 4 == 12, but we will onyl check till the sqaure root to be smart as afgter that it will start repeating but we might find it at a distance more than what we found in here as root(x) is less than x - root(x) if we check above root x it would be a waste of time one is like searching for people in a desert the other is like searching in a city \n    //     }\n    //     if(i * i == x) ans++; // if x is a perfect square then ans would be incremented by 1 only as it has 2 same factors\n    //     cout << ans << endl;\n    // }\n\n     for(int i = 0;i < n;i++){\n        int x;\n        cin >> x;\n        cout << some(x) << endl;\n     }\n\n    return 0;\n}",
  "maths/gene.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nvoid generatePrime(int n)\n{\n    int X = 0, i = 2;\n    bool flag;\n    while(X < n){\n        flag = true;\n        for(int j = 2; j <= sqrt(i); j++){\n            if (i%j == 0){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            cout << i << endl;\n            X++;\n        }\n        i++;\n    }\n    // cout << endl;\n}\n\nint main() {\n    setIO(\"gene\");\n\n    int n = 10000;\n\n    cout << n << endl;\n\n    generatePrime(n);\n\n    return 0;\n}",
  "maths/gene.in": "",
  "maths/somehing.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int MAXX = 1e6;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nvector<int> dp(MAXX+1);\n\nvoid phi_1_to_n(int n) {\n    // vector<int> phi(n + 1);\n    for (int i = 0; i <= n; i++)\n        dp[i] = i;\n\n    for (int i = 2; i <= n; i++) {\n        if (dp[i] == i) {\n            for (int j = i; j <= n; j += i)\n                dp[j] -= dp[j] / i;\n        }\n    }\n}\n\nvoid solve(int n){\n    ll odd = 0;\n    ll even = 0;\n\n    for(int i = 1;i <= n;i++){\n        if(i % 2) odd += dp[i];\n        else even += dp[i];\n    }\n\n    cout << abs(even - odd) << endl;\n}\n\n\nint main() {\n    setIO(\"check\");\n\n    phi_1_to_n(MAXX+1);\n\n    int t;\n    cin >> t;\n\n    while(t--){\n        int n;\n        cin >>n;\n        solve(n);\n    }\n\n    return 0;\n}",
  "misc/NusretG\u00f6k\u00e7e.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    long long n, m;\n\n    cin >> n >> m;\n    vector<long long> arr(n, 0);\n    for(int i = 0;i < n;i++) cin >> arr[i];\n\n    // got from left to right and then from right to left to confirm that you get the right shit\n\n    for(int i = 0;i < n-1;i++){\n        // check right and left what is happening, like change the smaller value if it doesn't satisfy\n        if(arr[i+1] > arr[i] + m){\n            arr[i] = arr[i+1] - m;\n        }\n        else if(arr[i] > arr[i+1] + m){\n            arr[i+1] = arr[i] - m;\n        }\n    }\n\n    for(int i = n-2;i >= 0;i--){\n        // check right and left what is happening, like change the smaller value if it doesn't satisfy\n        if(arr[i+1] > arr[i] + m){\n            arr[i] = arr[i+1] - m;\n        }\n        else if(arr[i] > arr[i+1] + m){\n            arr[i+1] = arr[i] - m;\n        }\n    }\n\n    for(int i: arr){\n        cout << i << ' ';\n    }\n    return 0;\n}",
  "misc/air_cownditioning.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\n\nvector<bool> uses;\nvector<vector<int>> cows;\nvector<vector<int>> acs;\nint ans = 1e6;\nint N, M;\n\n\nvoid solve(){\n    // vector<int> cooling(101, 0);\n    bool not_done = false;\n    for(int i=1;i <= 100;i++){\n        int cool = 0; // find coolinbg at that point and compare to the cow at that point as cows can't be more\n        for(int j=0;j < M;j++){\n            if(uses[j]){\n                int a = acs[j][0];\n                int b = acs[j][1];\n                int c = acs[j][2];\n                if(a <=  i && i <= b){\n                    cool += c;\n                }\n            }\n        }\n        // now find the cow\n        int cow = 0;\n        for(int j=0;j < N;j++){\n            int left = cows[j][0];\n            int right = cows[j][1];\n            int require = cows[j][2];\n            if(left <= i && right >= i){\n                cow = require;\n                break;\n            }\n        }\n\n        if(cool < cow){\n            not_done = true;\n            break;\n        }\n    }\n    if(!not_done){\n        int some = 0;\n        for(int i=0;i < M;i++){\n            if(uses[i]) some += acs[i][3];\n        }\n        ans = min(ans, some);\n    }\n}\n\n\nvoid helpp(int index){\n    // index of the AC to select or reject\n    if(index == M){\n        solve();\n        return;\n    }\n    // select the index\n    uses[index] = true;\n    helpp(index+1);\n    // deselect\n    uses[index] = false;\n    helpp(index+1); \n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    cows.resize(n, vector<int>(3));\n    for(int i=0; i < n;i++){\n        cin >> cows[i][0] >> cows[i][1] >> cows[i][2];\n    }\n    acs.resize(m, vector<int>(4));\n    for(int i=0; i < m;i++){\n        cin >> acs[i][0] >> acs[i][1] >> acs[i][2] >> acs[i][3];\n    }\n    \n    uses.resize(m, false);\n    ans = 1e6;\n    N = n;\n    M = m;\n    helpp(0);// select or unselect here \n    cout << ans <<endl;\n    return 0;\n}",
  "misc/bcount/bcount.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    ifstream fin(\"bcount.in\");\n    ofstream fout(\"bcount.out\"); \n    \n    int number_of_breeds = 3;\n\n    int n, q;\n    fin >> n >> q;\n\n    vector<vector<int>> arr(4, vector<int>(n+1, 0));\n\n    for(int i=1;i <= n;i++){\n        int val;\n        fin >> val;\n        arr[val][i] = 1;\n    }\n\n    for(int i=1;i <= number_of_breeds;i++){\n        for(int j = 2;j <= n;j++){\n            arr[i][j] += arr[i][j-1];\n        }\n    }\n\n    for(int i = 0;i < q;i++){\n        int l, r;\n        fin >> l >> r;\n        for(int j = 1;j <= number_of_breeds;j++){\n            fout << arr[j][r] - arr[j][l-1];\n            if(j != number_of_breeds) fout << ' '; \n        }\n        fout << endl;\n    }\n\n    return 0;\n}   ",
  "misc/bcount/bcount.in": "6 3\n2\n1\n1\n3\n2\n1\n1 6\n3 3\n2 4",
  "misc/bcount/bcount.out": "3 2 1\n1 0 0\n2 0 1\n",
  "misc/bipartiteness_cf.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing vvi = vector<vector<int>>;\nusing vi = vector<int>;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nbool dfs(vvi &adj, vi &color, int node, int col){\n    color[node] = col;\n    bool some = true;\n    for(int i : adj[node]){\n        if(color[i] == -1){\n            some = dfs(adj, color, i, !col);\n        }\n        else{\n            if(color[i] == col){\n                return false; \n            }\n        }\n    }\n    return some;\n}\n\nint main() {\n    setIO(\"\");\n\n    long long n;\n    cin >> n;\n\n    vvi adj(n+1);\n\n    for(long long i =0 ;i < n-1;i++){\n        long long u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vi color(n+1, -1);\n\n    bool bipar = dfs(adj, color, 1, 0);\n\n    if(!bipar){\n        cout << \"0\";\n        return 0;\n    }\n\n    long long color1 = 0;\n    long long color2 = 0;\n\n    long long edges_used = n - 1; // since its a tree n-1 edges for n nodes have already been used so from total color1 nodes mul by color2 nodes this would be subtracted\n\n    for(int i = 1;i <= n;i++){\n        if(color[i] == 0) color1++;\n        else color2++;\n    }\n\n    cout << (long long)color1*color2 - edges_used;\n\n    return 0;\n}",
  "misc/birthday_party.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>> &adj, vector<bool> &vis, int &c, int n){\n    c++;\n    vis[node] = true;\n\n    for(int i = 0;i < n;i++){\n        if(adj[node][i] && !vis[i]){\n            dfs(i, adj, vis, c, n);\n        }\n    }\n}\n\nvoid solve(int n, int m){\n    vector<vector<int>> adj(n, vector<int> (n, 0)); // Adj Matrix\n\n    vector<vector<int>> edges(m, vector<int> (2, 0));\n\n    for(int i = 0;i < m;i++){\n        int u, v;\n        cin >> u >> v;\n        edges[i][0] = u;\n        edges[i][1] = v;\n\n        adj[u][v] = 1;\n        adj[v][u] = 1;\n    }\n\n\n    for(int i = 0;i < m;i++){\n        int u = edges[i][0];\n        int v = edges[i][1];\n\n        adj[u][v] = false;\n        adj[v][u] = false;\n        vector<bool> vis(n, false);\n        int c = 0;\n\n        dfs(0, adj, vis, c, n);\n\n        if(c < n){cout << \"YES\\n\"; return;}\n\n        adj[u][v] = true;\n        adj[v][u] = true;\n    }\n    cout << \"NO\\n\";\n}\n\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, m;\n\n    while(cin >> n >> m && !(!n && !m)) solve(n, m);\n\n    return 0;\n}",
  "misc/books.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int n, t;\n    cin >> n >> t;\n    vector<int> arr(n+1);\n    for(int i=0;i < n;i++) cin >> arr[i+1];\n\n    int l = 1;\n    int r = 1;\n    int ans = 0;\n    while(r <= n){\n        if(t >= arr[r]){\n            t-=arr[r];\n            r++;\n        }\n        else{\n            t+= arr[l];\n            l++;\n        }\n        ans = max(ans, r-l);\n    }\n    cout << ans << endl;\n    return 0;\n}",
  "misc/cellular_network.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n\n    vector<long long> arr(n, 0);\n    vector<long long> towers(m, 0);\n\n    for(int i = 0;i < n;i++) cin >> arr[i];\n    for(int j = 0;j < m;j++) cin >> towers[j];\n\n    set<long long> s(towers.begin(), towers.end());\n\n    long long ans = 0;\n\n    for(int i = 0;i < n;i++){\n        long long val = arr[i];\n\n        long long distL = INT_MAX;\n        long long distR = INT_MAX;\n\n        auto right = s.lower_bound(val);\n        // right--;\n        auto left = right;\n        // right++;\n\n        if(left == s.begin()){\n            distR = abs((*right) - val);\n        }\n        else if(right == s.end()){\n            left--;\n            distL = abs(val - (*left));\n        }\n        else{\n            left--;\n            distL = abs(val - (*left));\n            distR = abs((*right) - val);\n        }\n\n        long long curr = min(distL, distR);\n        ans = max(ans, curr);\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}",
  "misc/cf_three_logos.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint n = 3;\n// int main()\n// {\n//     ios_base::sync_with_stdio(0);\n//     cin.tie(0);\n//     vector<vector<int>> vals(n, vector<int>(2, 0));\n//     for(int i=0;i < n;i++){\n//         cin >> vals[i][0] >> vals[i][1];\n//     }\n\n//     // first find the length of the thing to make the square\n//     long long area = 0; \n//     for(int i=0;i < n;i++){\n//         area += vals[i][0]*vals[i][1];\n//     }\n\n//     int sq = 1;\n\n//     while (sq * sq < area) { sq++; }\n//     if(sq*sq != area){\n//         cout << \"-1\" << \"\\n\";\n//         return 0;\n//     }\n//     // bit masking for all permutations 2^n, go from 0 to 2^n-1\n//     // use mask 1<<n\n//     for(int mask = 0;mask < 1<<n;mask++){\n//         // make a new grid\n//         vector<vector<char>> grid(sq, vector<char>(sq, '#'));\n//         int placed = 0;\n//         bool flag = false;\n//         for(int i=0;i < sq && !flag;i++){\n//             for(int j=0;j < sq&& !flag;j++){\n//                 if(grid[i][j] != '#'){\n//                     flag = true;\n//                     break;\n//                 }\n//                 // from bitmask make all permutations\n//                 int w = vals[placed][0];\n//                 int h = vals[placed][1];\n//                 if((1 << placed) & mask){\n//                     swap(w, h);\n//                 }\n//                 bool canPlace = true;\n//                 for(int k = i;k < i + w;k++){\n//                     for(int m = j;m < j + h;j++){\n//                         if(k >= sq|| m >= sq ||grid[k][m] == '#'){\n//                             canPlace = false;\n//                             break;\n//                         }\n//                     }\n//                     if (!canPlace) break;\n//                 }\n//                  if (!canPlace) {\n//                         flag = true;\n//                         break;\n//                     }\n                \n//                 for (int k = i; k < i + h; k++) {\n//                         for (int m = j; m < j + w; m++) {\n//                             grid[k][m] = placed + 'A';\n//                         }\n//                     }\n//                 placed++;\n//             }\n//             if(flag) break;\n//         }\n//         if(placed == n){\n//             for(int i=0;i < sq;i++){\n//                 for(int j=0;j < sq;j++){\n//                     cout << grid[i][j];\n//                 }\n//                 cout << \"\\n\";\n//             }\n//             return 0;\n//         }\n//     }\n//     cout << \"-1\" << \"\\n\";\n//     return 0;\n// }\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    vector<vector<int>> vals(n, vector<int>(2, 0));\n    for (int i = 0; i < n; i++) {\n        cin >> vals[i][0] >> vals[i][1];\n    }\n\n    // Calculate the total area\n    long long area = 0;\n    for (int i = 0; i < n; i++) {\n        area += vals[i][0] * vals[i][1];\n    }\n\n    // Find the side of the square\n    int sq = 1;\n    while (sq * sq < area) sq++;\n    if (sq * sq != area) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    // Try all rotations using bitmask\n    for (int mask = 0; mask < (1 << n); mask++) {\n        vector<vector<char>> grid(sq, vector<char>(sq, '#'));\n        int placed = 0;\n        bool flag = true;\n\n        for (int i = 0; i < sq && flag; i++) {\n            for (int j = 0; j < sq && flag; j++) {\n                if (grid[i][j] == '#' && placed < n) {\n                    int w = vals[placed][0];\n                    int h = vals[placed][1];\n                    if ((1 << placed) & mask) swap(w, h);\n\n                    // Check if the logo can be placed\n                    bool canPlace = true;\n                    for (int k = i; k < i + h; k++) {\n                        for (int m = j; m < j + w; m++) {\n                            if (k >= sq || m >= sq || grid[k][m] != '#') {\n                                canPlace = false;\n                                break;\n                            }\n                        }\n                        if (!canPlace) break;\n                    }\n\n                    if (!canPlace) {\n                        flag = false;\n                        break;\n                    }\n\n                    // Place the logo\n                    for (int k = i; k < i + h; k++) {\n                        for (int m = j; m < j + w; m++) {\n                            grid[k][m] = placed + 'A';\n                        }\n                    }\n                    placed++;\n                }\n            }\n        }\n\n        if (flag && placed == n) {\n            cout << sq << \"\\n\";\n            for (int i = 0; i < sq; i++) {\n                for (int j = 0; j < sq; j++) {\n                    cout << grid[i][j];\n                }\n                cout << \"\\n\";\n            }\n            return 0;\n        }\n    }\n\n    cout << \"-1\\n\";\n    return 0;\n}",
  "misc/check.in": "4\n1\n8\n4\n3\n",
  "misc/check.out": "",
  "misc/check/check.in": "6\n1 1\n.\n1 2\nG.\n2 2\n#B\nG.\n2 3\nG.#\nB#.\n3 3\n#B.\n#..\nGG.\n2 2\n#B\nB.\n",
  "misc/check/check.out": "YES\nYES\nNO\nNO\nYES\nYES\n",
  "misc/closing/closing.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int node, vector<set<int>> &adj, vector<bool> &vis){\n    vis[node] = true;\n\n    for(int i: adj[node]){\n        if(!vis[i]){\n            dfs(i, adj, vis);\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    ifstream fin(\"closing.in\");\n    ofstream fout(\"closing.out\");\n\n    int n, m;\n    fin >> n >> m;\n\n    vector<set<int>> adj(n+1);\n\n    for(int i = 0;i < m;i++){\n        int u, v;\n        fin >>u >> v;\n        adj[u].insert(v);\n        adj[v].insert(u);\n    }\n\n    vector<bool> removed(n+1, false);\n    set<int> rset;\n\n    for(int i = 0;i < n;i++){\n        int node = 0;\n        fin >> node;\n        vector<bool> vis(n+1, false);\n\n        int ss = 0;\n\n        for(int i = 1;i <= n;i++){\n            if(!removed[i]){\n                ss = i;\n                break;\n            }\n        }\n\n        dfs(ss, adj, vis);\n\n        for(int i = 1;i <= n;i++){\n            if(!vis[i] && rset.find(i) == rset.end()){\n                fout << \"NO\" << endl;\n                ss = 0;\n                break;\n            }\n        }\n\n        if(ss) fout << \"YES\" << endl;\n\n        removed[node] = true;\n        rset.insert(node);\n\n        adj[node].clear();\n\n        for(int i = 1;i <= n;i++){\n            if(adj[i].find(node) != adj[i].end()) adj[i].erase(node);\n        }\n\n    }\n\n    return 0;\n}",
  "misc/closing/closing.in": "4 3\n1 2\n2 3\n3 4\n3\n4\n1\n2",
  "misc/closing/closing.out": "YES\nNO\nYES\nYES\n",
  "misc/div7/div7.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    ifstream fin(\"div7.in\");\n    ofstream fout(\"div7.out\");\n\n    int n;\n    fin >> n;\n    vector<long long> arr(n);\n    for(int i=0;i < n;i++){\n        fin >> arr[i];\n    }\n\n    for(int i=1;i < n;i++){\n        arr[i] = arr[i]+arr[i-1];\n    }\n\n    int ans = 0;\n\n    // for(int i=0;i < n;i++){\n    //     for(int j = n-1;j >= i;j--){\n    //         long long some = (i > 0)?(arr[j] - arr[i-1]): arr[j];\n    //         if(some % 7 == 0){\n    //             ans = max(ans, j - i + 1);\n    //             break;\n    //         }\n    //     }\n    // }\n    vector<int> mods(n);\n    vector<int> first_repeat(7, -1);\n    for(int i=0;i < n;i++){\n        mods[i] = arr[i]%7;\n        if(first_repeat[mods[i]] == -1) first_repeat[mods[i]] = i;\n        else ans = max(ans, i - first_repeat[mods[i]]);\n    }\n\n    fout << ans;\n\n    // for(int i=0;i < n;i++){\n    //     cout << arr[i] << ' ';\n    // }\n    return 0;\n}",
  "misc/div7/div7.in": "7\n3\n5\n1\n6\n2\n14\n10",
  "misc/div7/div7.out": "5",
  "misc/edu173/1.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\n\nlong long solve(long long n){\n    // if(n <= 4) return 1;\n    // return 2*solve(n/4);\n    long long curr = 1;\n    while(n>=4){\n        curr = 2*curr;\n        n = n/4;\n    }\n    return curr;\n}\n\nint main()\n{\n    int t;\n    cin >> t;\n    while(t--){\n        long long n;\n        cin >> n;\n        cout << solve(n)<< '\\n';\n    }\n    return 0;\n}",
  "misc/edu173/2.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int t;\n    cin >> t;\n    while(t--){\n        int n, d;\n        cin >> n >> d;\n        cout << 1 << ' ';\n        if(n >= 3 || d %3 == 0){\n            cout << 3 << ' ';\n        }\n        if(d == 5){\n            cout << 5 << ' ';\n        }\n        if(d == 7 || n >= 3){\n            cout << 7 << ' ';\n        }\n        if(d == 9 || n>=6 || (d%3==0 && n>=3)){\n            cout << 9 << ' ';\n        }\n        cout << endl;\n    }\n    return 0;\n}",
  "misc/edu173/3.cpp": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nvoid solve() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        int x = 0, x_pos = -1;\n\n        // Read the array and identify the special element `x` and its position\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            if (a[i] != 1 && a[i] != -1) {\n                x = a[i];\n                x_pos = i;\n            }\n        }\n\n        // Create a set to store all unique subarray sums\n        set<long long> result_sums;\n\n        // Step 1: Calculate subarray sums from the left side (before `x`)\n        long long current_sum = 0;\n        result_sums.insert(0);  // empty subarray\n        for (int i = 0; i < x_pos; i++) {\n            current_sum += a[i];\n            result_sums.insert(current_sum);\n        }\n\n        // Step 2: Calculate subarray sums from the right side (after `x`)\n        current_sum = 0;\n        for (int i = n - 1; i > x_pos; i--) {\n            current_sum += a[i];\n            result_sums.insert(current_sum);\n        }\n\n        // Step 3: Consider the sums that involve `x` itself\n        // We need to combine sums from the left part, x, and right part.\n        set<long long> left_sums = {0};\n        current_sum = 0;\n        for (int i = 0; i < x_pos; i++) {\n            current_sum += a[i];\n            left_sums.insert(current_sum);\n        }\n\n        set<long long> right_sums = {0};\n        current_sum = 0;\n        for (int i = n - 1; i > x_pos; i--) {\n            current_sum += a[i];\n            right_sums.insert(current_sum);\n        }\n\n        // Add the combinations of left sums + x + right sums\n        for (auto left : left_sums) {\n            for (auto right : right_sums) {\n                result_sums.insert(left + x + right);\n            }\n        }\n\n        // Output the result\n        cout << result_sums.size() << endl;\n        for (auto sum : result_sums) {\n            cout << sum << \" \";\n        }\n        cout << endl;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    solve();\n    return 0;\n}\n",
  "misc/edu173/3.py": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    idx = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        a = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        # Identify `x` and calculate prefix sums for `1` and `-1` only\n        prefix_sum = 0\n        possible_sums = set()\n        x = None\n        x_pos = -1\n        \n        for i in range(n):\n            if a[i] not in (-1, 1):\n                x = a[i]\n                x_pos = i\n                continue\n            \n            # Update prefix sum for only `1` and `-1`\n            prefix_sum += a[i]\n            possible_sums.add(prefix_sum)\n        \n        # Include zero sum (empty subarray)\n        possible_sums.add(0)\n        \n        # Handle the influence of `x`\n        if x is not None:\n            new_sums = set()\n            for s in possible_sums:\n                new_sums.add(s)  # Without `x`\n                new_sums.add(s + x)  # Including `x`\n            possible_sums = new_sums\n        \n        # Sort and prepare the result\n        result = sorted(possible_sums)\n        results.append(f\"{len(result)}\\n{' '.join(map(str, result))}\")\n    \n    # Print all results at once\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nsolve()",
  "misc/edu173/4.cpp": "#include <iostream>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// Function to compute GCD of two numbers\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// long long gcd(long long a, long long b)\n// {\n//     /* GCD(0, b) == b; GCD(a, 0) == a,\n//     GCD(0, 0) == 0 */\n//     if (a == 0)\n//         return b;\n//     if (b == 0)\n//         return a;\n\n//     /*Finding K, where K is the\n//     greatest power of 2\n//     that divides both a and b. */\n//     long long k;\n//     for (k = 0; ((a | b) & 1) == 0; ++k) \n//     {\n//         a >>= 1;\n//         b >>= 1;\n//     }\n\n//     /* Dividing a by 2 until a becomes odd */\n//     while ((a & 1) == 0)\n//         a >>= 1;\n\n//     /* From here on, 'a' is always odd. */\n//     do\n//     {\n//         /* If b is even, remove all factor of 2 in b */\n//         while ((b & 1) == 0)\n//             b >>= 1;\n\n//         /* Now a and b are both odd.\n//         Swap if necessary so a <= b,\n//         then set b = b - a (which is even).*/\n//         if (a > b)\n//         {\n//             long long tmp = a; // Swap u and v.\n//             a = b;\n//             b = tmp;\n//         }\n//         b = (b - a);\n//     }while (b != 0);\n\n//     /* restore common factors of 2 */\n//     return a << k;\n// }\n\n\nvoid solve() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        long long l, r, G;\n        cin >> l >> r >> G;\n\n        long long A = ((l + G - 1) / G) * G; \n\n        long long B = (r / G) * G;\n        while (A <= B && gcd(A, B) != G) {\n            B = B - G; \n        }\n\n        if (A > B) {\n            cout << \"-1 -1\" << endl;\n        } else {\n            cout << A << \" \" << B << endl;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    solve();\n    return 0;\n}",
  "misc/fenceplan/fenceplan.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    \n\n    return 0;\n}",
  "misc/fenceplan/fenceplan.in": "7 5\n0 5\n10 5\n5 0\n5 10\n6 7\n8 6\n8 4\n1 2\n2 3\n3 4\n5 6\n7 6",
  "misc/gcd_blackboard.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\n\nint gcd(int a, int b)\n{\n\n    if(b == 0) {\n        return a;\n    }\n    else {\n        return gcd(b, a % b);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for(int i=0;i < n;i++) cin >> arr[i];\n\n    vector<int> pgcd(n+2); // prefix gcd\n    vector<int> sgcd(n+2); // suffix gcd\n\n    pgcd[0] = 0;\n    sgcd[0] = 0;\n    //gcd(0, X) = X\n\n    sgcd[n+1] = 0;\n    pgcd[n+1] = 0;\n\n    \n    for(int i = 1;i <= n;i++){\n        pgcd[i] = gcd(pgcd[i-1], arr[i-1]);\n    }\n\n    for(int i = n;i >= 1;i--){\n        sgcd[i] = gcd(sgcd[i+1], arr[i-1]);\n    }\n\n    // just the value where i is there look around it how its changing and stuff\n\n    int ans = 0;\n    for(int i=1;i <= n;i++){\n        ans = max(ans, gcd(sgcd[i+1], pgcd[i-1]));\n    }\n\n    // for(int i: pgcd) cout << i << ' ';\n    // cout << '\\n';\n    // for(int i: sgcd) cout << i << ' ';\n    // cout << '\\n';\n\n    cout << ans << '\\n';\n    return 0;\n}",
  "misc/good_sub.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<long long> arr(n+1);\n        arr[0] = 0;\n        for(int i=1;i <= n;i++){\n            char c;\n            cin >> c;\n            arr[i] = (long long)(c - '0');\n        }\n\n        map<long long, int> times_pi_i;\n        // use map instead of unordered_map here as its a bit more fool pproof of TLE stuff O(logn) but worth it in the long run\n        for(int i = 1;i <= n;i++) arr[i] += arr[i-1];\n        // using i = 0 already adds the base case of times_pi_i[0] = 1;\n        for(int i = 0;i <= n;i++){\n            times_pi_i[arr[i] - i]++;\n        }\n        long long ans = 0;\n        for(auto &[keys, vals] : times_pi_i){\n            ans += (long long)vals*(vals-1)/2;\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}",
  "misc/greg_array.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<long long> arr(n+1);\n    vector<long long> addition(n+2, 0);\n    for(int i = 1;i <= n;i++) cin >> arr[i];\n\n    vector<vector<int>> oper(m+1, vector<int>(3));\n    for(int i = 1;i <=m;i++){\n        cin >> oper[i][0] >> oper[i][1] >> oper[i][2];\n    }\n\n    vector<int> queries(m+2, 0);\n    for(int i = 1;i <= k;i++){\n        int x, y;\n        cin >> x >> y;\n        queries[x]++;\n        queries[y+1]--;\n    }\n\n    for(int i = 1;i <= m;i++){\n        queries[i] += queries[i-1];\n        // queries[i] is how many times you have to excecute it(the query i) on that so multiply x and y+1 with this\n        int x = oper[i][0];\n        int y = oper[i][1];\n        int d = oper[i][2];\n\n        // apply the query\n        addition[x] += (long long)d*queries[i];\n        addition[y+1] -= (long long)d*queries[i];\n    }\n\n    for(int i = 1;i <= n;i++){\n        addition[i] += addition[i-1];\n        cout << arr[i] + addition[i] << ' ';\n    }\n    return 0;\n}",
  "misc/haybale_imp_concept.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int n, k;\n    cin >> n >> k;\n    vector<int> arr(n+2, 0);\n    long long suma = 0;\n    for(int i=0;i < k;i++){\n        int r, l;\n        cin >> l >> r;\n        arr[l] += 1;\n        arr[r+1] -= 1;\n    }\n\n    for(int i=0;i <= n;i++){\n        suma += arr[i];\n        arr[i] = suma;\n    }\n\n    sort(arr.begin() + 1, arr.end() - 1);\n\n    if(n%2 == 0){\n        cout << (arr[n/2+1] + arr[n/2 + 2])/2 << endl;\n    }\n    else{\n        cout << arr[n/2 + 1] << endl;\n    }\n    return 0;\n}",
  "misc/haybales/haybales.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    setIO(\"haybales\");\n    int n, q;\n    cin >> n >> q;\n    vector<int> arr(n, 0);\n\n    for(int i = 0;i < n;i++) cin >> arr[i];\n    sort(arr.begin(), arr.end());\n    for(int i = 0;i < q;i++){\n        int a, b;\n        cin >> a >> b;\n\n        cout << upper_bound(arr.begin(), arr.end(), b) - lower_bound(arr.begin(), arr.end(),a) << endl;\n    }\n\n    return 0;\n}",
  "misc/haybales/haybales.in": "4 6\n3 2 7 5\n2 3\n2 4\n2 5\n2 7\n4 6\n8 10",
  "misc/haybales/haybales.out": "2\n3\n3\n4\n2\n1\n",
  "misc/high_card_low_card.cpp": "#include<bits/stdc++.h>\n#include <vector>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\n\nvoid disp(vector<int> &arr){\n    for(int i: arr) cout << i << \" \";\n    cout << endl;\n}\nvoid disp(set<int> &arr){\n    for(int i: arr) cout << i << \" \";\n    cout << endl;\n}\n\n\nint main() {\n    setIO(\"cardgame\");\n    int n;\n    cin >> n;\n\n    vector<int> elsie(n);\n\n    for(int i = 0;i < n;i++) cin >> elsie[i];\n\n    vector<int> arr;\n\n    set<int> some(elsie.begin(), elsie.end());\n\n    for(int i = 1;i <= 2*n;i++){\n        if(some.find(i) == some.end()){\n            arr.push_back(i);\n        }\n    }\n\n    sort(arr.begin(), arr.end());\n\n    // first N/2 like the smallest would be used for the end while largest for the start\n    //\n\n    set<int> start;\n    set<int> last;\n\n    for(int i = 0;i < n/2;i++){\n        last.insert(arr[i]);\n    }\n    for(int i = n/2;i < n;i++){\n        start.insert(arr[i]);\n    }\n\n    // disp(arr);\n    // disp(start);\n    // disp(last);\n\n    int ans = 0;\n\n    for(int i = 0;i < n/2;i++){\n        int opp_card =elsie[i];\n        auto it = start.upper_bound(opp_card);\n        if(it != start.end()){\n            if(opp_card < *it){\n                ans++;\n                start.erase(it);\n            }\n        }\n    }\n    for(int i = n/2;i < n;i++){\n        int opp_card =elsie[i];\n        auto it = last.upper_bound(opp_card);\n        it--;\n        if(it != last.end()){\n            if(opp_card > *it){\n                ans++;\n                last.erase(it);\n            }\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}\n",
  "misc/kayaking.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<int> arr(2*n);\n    for(int i=0;i < 2*n;i++){\n        cin >> arr[i];\n    }\n\n    int ans = INT_MAX;\n    sort(arr.begin(), arr.end());\n    // keep everything in single kayaks atleast once\n    for(int i = 0;i < 2*n;i++){\n        for(int j = i+1;j < 2*n;j++){\n            vector<int> narr(2*n-2);\n            int c = 0;\n            for(int k = 0;k < 2*n;k++){\n                if(k != i && k != j) narr[c++] = arr[k];\n            }\n\n            int temp = 0;\n\n            for(int k = 0;k < 2*n - 2;k+=2){\n                temp += narr[k+1] - narr[k];\n            }\n            ans = min(temp, ans);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}",
  "misc/lazycow/lazy.cpp": "// #include<bits/stdc++.h>\n// using namespace std;\n\n\n// int main(){\n//     ios::sync_with_stdio(0);\n//     cin.tie(0);\n//     ifstream fin(\"lazy.in\");\n//     ofstream fout(\"lazy.out\");\n\n//     int n, k;\n//     fin >> n >> k;\n//     vector<vector<int>> ogarr(n+1, vector<int>(n+1, 0));\n//     vector<vector<int>> arrnew(2*n+1, vector<int>(2*n+1, 0));\n\n//     for(int i=1;i <= n;i++){\n//         for(int j = 1;j <= n;j++){\n//             fin >> ogarr[i][j];\n//         }\n//     }\n\n//     int space = n - 1;\n//     int j = 1;\n//     for(int c = 2;c <= n+1;c++){\n//         vector<int> node(c+2);\n//         int k = 1;\n//         for(int x = c-1; x >= 1;x--){\n//             node[k++] = ogarr[x][c-x];\n//         }\n//         // cout << k;\n//         k = 1;\n//         for(int i = space + 1;k <= c;){\n//             arrnew[j][i] = node[k];\n//             // k += 2;\n//             k++;\n//             i+=2;\n//         }\n//         j++;\n//         space--;\n//     }\n//     space = 1;\n//     for(int c = n+2;c <= 2*n;c++){\n//         vector<int> node(c - n + 2);\n//         int k = 1;\n//         for(int x = c-1; x >= 1;x--){\n//             node[k++] = ogarr[x][c-x];\n//         }\n//         k = 1;\n//         for(int i = space + 1;k <= c - n;){\n//             arrnew[j][i] = node[k];\n//             k ++;\n//             i+=2;\n//         }\n//         j++;\n//         space++;\n//     }\n\n//     printarr(arrnew);\n//     return 0;\n// }\n\n// // #include <bits/stdc++.h>\n// // using namespace std;\n\n// // void printarr(vector<vector<int>> &arr) {\n// //     for (vector<int> &row : arr) {\n// //         for (int val : row) {\n// //                 cout << val << ' ';\n// //                 cout << \"  \"; // Print spaces for alignment\n// //         }\n// //         cout << '\\n';\n// //     }\n// // }\n\n// // int main() {\n// //     ios::sync_with_stdio(0);\n// //     cin.tie(0);\n// //     ifstream fin(\"lazy.in\");\n// //     ofstream fout(\"lazy.out\");\n\n// //     int n, k;\n// //     fin >> n >> k;\n// //     vector<vector<int>> ogarr(n, vector<int>(n, 0)); // Original array\n// //     vector<vector<int>> arrnew(2 * n - 1, vector<int>(2 * n - 1, 0)); // Rotated array with pyramid shape\n\n// //     // Read the input matrix\n// //     for (int i = 0; i < n; i++) {\n// //         for (int j = 0; j < n; j++) {\n// //             fin >> ogarr[i][j];\n// //         }\n// //     }\n\n// //     // Perform 45-degree rotation and align in pyramid format\n// //     for (int i = 0; i < n; i++) {\n// //         for (int j = 0; j < n; j++) {\n// //             int diag = i + j;        // Determine diagonal index\n// //             int center = n - 1;      // Center position in each row\n// //             int pos = center - i + j; // Adjust position for pyramid alignment\n// //             arrnew[diag][pos] = ogarr[i][j];\n// //         }\n// //     }\n\n// //     // Print the rotated and aligned array\n// //     printarr(arrnew);\n// //     return 0;\n// // }\n\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nvoid printarr(vector<vector<int>> &arr){\n    for(vector<int> i: arr){\n        for(int j : i){\n            cout << j << ' ';\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    ifstream fin(\"lazy.in\");\n    ofstream fout(\"lazy.out\");\n\n    int n, k;\n    fin >> n >> k;\n    vector<vector<int>> ogarr(n+1, vector<int>(n+1, 0));\n    vector<vector<int>> arrnew(2*n+1, vector<int>(2*n+1, -1));\n\n    for(int i=1;i <= n;i++){\n        for(int j = 1;j <= n;j++){\n            fin >> ogarr[i][j];\n        }\n    }\n\n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= n;j++){\n            int newX = i + j - 1;// -2 would be 0 indexed\n            int newY = n - i + j;// lower you go with the same Y you get lefter, the change the Y axis to x = n so the new coordinates would be n - x + y, or use the coordinate transformation, or rotate the graph in your mind y = x is the new X axis\n            arrnew[newX][newY] = ogarr[i][j];\n        }\n    }\n\n    vector<vector<int>> pref(2*n+1, vector<int>(2*n+1, 0));\n\n    // printarr(arrnew);\n\n    for(int i = 1;i <= 2*n-1;i++){\n        for(int j = 1;j <= 2*n-1;j++){\n            int some = (arrnew[i][j] == -1)?0:arrnew[i][j];\n            pref[i][j] = some + pref[i-1][j] + pref[i][j-1] -pref[i-1][j-1];\n        }\n    }\n\n    // printarr(arrnew);\n\n    long long ans = 0;\n    // if this k wasn't given then it would have taken O(n^3) atleast\n    for(int i = k+1;i <= 2*n-k-1;i++){\n        for(int j = k+1;j <= 2*n-k-1;j++){\n            if(pref[i][j] == -1) continue;\n            long long curr_sum = 0;\n            // curr_sum = pref[i+k+1][j+k+1] + pref[i-k][j-k] - pref[i+k+1][j-k] - pref[i-k][j+k+1];\n            // ans = max(ans, curr_sum);\n\n            int x1 = max(0, i - k);\n            int y1 = max(0, j - k);\n            int x2 = min(2*n-1, i + k);\n            int y2 = min(2*n-1, j + k);\n\n            curr_sum = pref[x2][y2];\n            if(x1>0) curr_sum -= pref[x1-1][y2];\n            if(y1>0) curr_sum -= pref[x2][y1-1];\n            if(y1>0&&x1>0) curr_sum += pref[x1-1][y1-1];\n            ans = max(ans, curr_sum);\n        }\n    }\n\n    if(k >= n) ans = pref[2*n-1][2*n-1];\n\n    fout << ans;\n\n    return 0;\n}",
  "misc/lazycow/lazy.in": "5 2\n50 5 25 6 17\n14 3 2 7 21\n99 10 1 2 80\n8 7 5 23 11\n10 0 78 1 9",
  "misc/lazycow/lazy.out": "342",
  "misc/leaping_tak.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\nint mod = 998244353;\nint main(){\n    int n, k;\n    cin >> n >> k;\n    vector<pii> ranges(k);\n    // set<int> s;\n    for(int i = 0;i < k;i++){\n        int l, r;\n        cin >> l >> r;\n        ranges[i].first = l;\n        ranges[i].second = r;\n    }\n    \n    // here make a DP array which stores how many ways are there to reach 'i' you can always reach 0 in 1 way and the DP array would be a contiguous difference array in which we will sum with the for loop\n    vector<long long> dp(n+2, 0);\n    dp[0] = 1;// using 0 indexed as the person in question was standing on 1 here he will stand on 1\n    dp[1] = -1; //using difference array\n    for(int i = 0;i < n;i++){\n        if(i > 0) dp[i] = (dp[i] + dp[i-1])%mod;//convert from difference form to actual form\n        for(int j = 0;j < k;j++){\n            int l = ranges[j].first;\n            int r = ranges[j].second;\n\n            // continue to difference form\n            // here we can say there are atleast dp[i] ways when not in difference form to reach i + l thats why this form\n            if(i + l <= n) dp[i + l] = (dp[i + l]%mod + dp[i])%mod;\n            if(i + r <= n) dp[i + r + 1] = (dp[i + r + 1]%mod - dp[i])%mod;\n        }\n    }\n    long long ans = 0;\n    ans = (dp[n-1]+mod)%mod; // 0 indexed thats why n-1 as here we go from 0 to n-1 instead of 1 to n\n    cout << ans << endl;\n    return 0;\n}",
  "misc/little_girl_max_sum.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n, q;\n    long long ans = 0;\n    cin >> n >> q;\n    vector<int> arr(n+1, 0);\n    for(int i = 1;i <= n;i++) cin >> arr[i];\n    sort(arr.begin()+1, arr.end());\n    vector<long long> queries(n+2, 0);\n    for(int i = 1;i <= q;i++){\n        int x, y;\n        cin >> x >> y;\n        queries[x]++;\n        queries[y+1]--;\n    }\n\n    for(int i = 1;i <= n;i++) queries[i] += (long long)queries[i-1];\n    sort(queries.begin() + 1, queries.end() - 1);\n    // the queries array tells us how many times the index is repeated in all the queries there we sort it and multiply max value with max value which works\n    // else do it with BIT(Binary Indexed Trees)\n    for(int i = 1;i <= n;i++) ans += (long long)arr[i]*queries[i];\n    cout << ans << endl;\n    return 0;\n}",
  "misc/max_median_cf.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nll n, k;\nvector<ll> arr;\n\nbool function_check(ll new_med){\n    ll operation = 0;\n    for(int i = (n)/2 ;i < n;i++){ // difference with all whatever needs changing add it to the operation\n        if(arr[i] < new_med) operation += (new_med - arr[i]);\n        if(k < operation) return false; // here the thing already failed\n    }\n\n    return k >= operation;\n}\n\nint main() {\n    // setIO(\"check/check\");\n    cin >> n >> k;\n\n    arr.resize(n, 0);\n\n    for(int i = 0;i < n;i++) cin >> arr[i];\n\n    // binary search on all medians and find the last true value as its basically a monotonically non increasing function\n    // find the most value at which its satisfied\n\n    // last_true function basically; 11110000 that type of a function\n    sort(arr.begin(), arr.end());\n    ll lo, hi;\n    lo = 0;\n    hi = INT32_MAX;\n    ll mid = 0;\n    while(lo < hi){\n        mid = lo + (hi - lo + 1)/2; // this mid is the new median to check on\n        if(function_check(mid)){\n            lo = mid; // this could also be the answer thats why no +-1\n        }\n        else hi = mid - 1; // answer could be just before check the graph that makes it super clear\n    }\n    // lo is the answer in the end as mid - 1 must be smaller than lo and that was the number which satisied the function in the end\n    cout << lo;\n\n    return 0;\n}",
  "misc/meeting_cant_be_changed.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nbool right_max_time = false, left_max_time = false;\n\n double get_time( double location, vector< double> &vs, vector< double> &xs){\n    // maximum time it takes to reach would be the answer\\\n\n    // if the time max from both the sides then we have reached the best position we can\n    right_max_time = false, left_max_time = false;\n     double timee = 0;\n    int n = vs.size();\n    for(int i = 0;i < n;i++){\n        if(location == xs[i]) continue;\n         double curr_time = abs(location - xs[i])/vs[i];\n        if(curr_time > timee){\n            timee = curr_time;\n            right_max_time = false;\n            left_max_time = false;\n            if(location < xs[i]){\n                right_max_time = true;\n            }\n            else{\n                left_max_time = true;\n            }\n        }\n        else if(curr_time == timee){\n            // time = curr_time; // not needed\n            if(location < xs[i]){\n                right_max_time = true;\n            }\n            else{\n                left_max_time = true;\n            }\n        }\n    }\n\n    return timee;\n}\n\nint main() {\n    // setIO(\"check\");\n    int n;\n    cin >> n;\n\n    vector< double> xs(n);\n    vector< double> vs(n);\n     double maxxi = 0;\n    for(int i = 0;i < n;i++){\n        cin >> xs[i];\n        maxxi = max(maxxi, ( double)xs[i]);\n    }\n    for(int i = 0;i < n;i++){\n        cin >> vs[i];\n    }\n\n    cout << setprecision(10);\n\n     double ans = ( double)1e18;\n     double high = maxxi;\n     double low = 0;\n    const  double accuracy = 10e-7;\n    // or use time's binary search\n    double curr_time;\n    double mid;\n    while(high - low > accuracy){\n        mid = (high + low)/2;\n        // check the distance, find the minimum time for it\n        // and also check for the thing like which is farther from the actual location\n        // so what we can do is if left is showing the minimum one then the issue is with the left\n        // so search in the left that would be better\n        //\n\n        curr_time = get_time(mid, vs, xs);\n\n        // if both max then best, if one is max then search in that space\n        //\n        ans = min(ans, curr_time);\n        if(right_max_time && left_max_time){\n            break;\n        }\n        else if(left_max_time)high = mid;\n        else{\n            low = mid;\n        }\n    }\n\n    cout << fixed << ans;\n\n    return 0;\n}\n",
  "misc/moocast/moocast.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(int node, vector<vector<int>>&adj, vector<bool> &vis, int &running){\n    vis[node] = true;\n    running++;\n\n    for(int i: adj[node]){\n        if(!vis[i]){\n            dfs(i, adj, vis, running);\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    ifstream fin(\"moocast.in\");\n    ofstream fout(\"moocast.out\");\n    int n;\n    fin >> n;\n\n    vector<vector<int>> input(n);\n\n    for(int i = 0;i < n;i++){\n        int x, y, p;\n        fin >> x >> y >> p;\n        input[i] = {x, y, p};\n    }\n\n    vector<vector<int>> adj(n);\n\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j < n;j++){\n            if(i == j) continue;\n            int x1 = input[i][0];\n            int y1 = input[i][1];\n            int x2 = input[j][0];\n            int y2 = input[j][1];\n            int p = input[i][2];\n            int dist = (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\n            if(dist <= p*p){\n                adj[i].push_back(j);\n            }\n        }\n    }\n\n\n    int ans = 0;\n\n    for(int i = 0;i < n;i++){\n        vector<bool> vis(n, false);\n        int running = 0;\n        dfs(i, adj, vis, running);\n        ans = max(ans, running);\n    }\n\n    fout << ans;\n\n    return 0;\n}",
  "misc/moocast/moocast.in": "4\n1 3 5\n5 4 3\n7 2 1\n6 1 1",
  "misc/moocast/moocast.out": "3",
  "misc/moocast_gold/moocast.in": "4\n1 3\n5 4\n7 2\n6 1",
  "misc/moocast_gold/moocast.out": "17",
  "misc/moocast_gold/moocast_gold.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing vvi = vector<vector<int>>;\nusing vi = vector<int>;\n\nclass DSU{\npublic:\n    vector<int> parent;\n    vector<int> size;\n\n    DSU(int n){\n        parent.resize(n, 0);\n        size.resize(n, 1);\n\n        for(int i = 0;i < n;i++){\n            parent[i] = i;\n        }\n    }\n\n    int findPar(int node){\n        if(parent[node] == node) return node;\n        return parent[node] = findPar(parent[node]);\n    }\n\n    void uniteSize(int n1, int n2){\n        int u, v;\n        u = findPar(n1);\n        v = findPar(n2);\n        if(u == v) return;\n        else if(size[u] < size[v]){\n            parent[u] = v;\n            size[v] += size[u];\n        }\n        else{\n            parent[v] = u;\n            size[u] += size[v];\n        }\n    }\n};\n\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    setIO(\"moocast\");\n    int n;\n    cin >> n;\n\n    vvi edges(n, vi(2, 0));\n\n    for(int i = 0;i < n;i++){\n        cin >> edges[i][0] >> edges[i][1];\n    }\n\n    // node name would be the index on the edges;\n\n    vvi allConnections;\n\n    for(int i = 0;i < n;i++){\n        for(int j = i+1; j < n;j++){\n            int x1 = edges[i][0];\n            int y1 = edges[i][1];\n            int x2 = edges[j][0];\n            int y2 = edges[j][1];\n            int dist = (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2);\n            allConnections.push_back({dist, i, j});\n        }\n    }\n\n    sort(allConnections.begin(), allConnections.end());\n    int all = allConnections.size();\n    DSU ds = DSU(n);\n\n    long long ans = 0;\n\n    for(int i = 0;i < all;i++){\n        int w = allConnections[i][0];\n        int x = allConnections[i][1];\n        int y = allConnections[i][2];\n        if(ds.findPar(x) != ds.findPar(y)){\n            // ans += (w);\n            ans = max(ans, (long long)w);\n            ds.uniteSize(x, y);\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}",
  "misc/notlast/notlast.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    ifstream fin(\"notlast.in\");\n    ofstream fin(\"notlast.out\");\n    int n;\n    fin >> n;\n\n    for(){\n        \n    }\n    return 0;\n}",
  "misc/notlast/notlast.in": "",
  "misc/nuske_vs_phantom.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\n// vector <int> integerToArray(int x)\n// {\n//     vector <int> resultArray;\n//     while (true)\n//     {\n//     resultArray.insert(resultArray.begin(), x%10);\n//     x /= 10;\n//     if(x == 0)\n//         return resultArray;\n//     }\n// }\n\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n, m, q;\n    cin >> n >> m >> q;\n\n    vector<vector<int>> arr(n+2, vector<int>(m+2, 0));\n    \n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= m;j++){\n            // this is important, like very important to take input in the form of characters\n            char c;\n            cin >> c;\n            c = c - '0';\n            arr[i][j] = c;\n        }\n    }\n\n    vector<vector<int>> pref(n+2, vector<int>(m+2, 0));\n\n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= m;j++){\n            pref[i][j] = pref[i-1][j] + pref[i][j-1] - pref[i-1][j-1];\n            if(!arr[i][j]) continue;\n            if((!arr[i-1][j]) && (!arr[i][j-1])){\n                pref[i][j]++;\n            }\n            else if(arr[i][j-1] && arr[i-1][j]) pref[i][j]--;\n        }\n    }\n\n    // ofstream fout(\"test.out\");\n\n    // for(vector<int> i: pref){\n    //     for(int j: i){\n    //         fout << j << ' ';\n    //     }\n    //     fout << endl;\n    // }\n\n    vector<vector<int>> hori(n+2, vector<int>(m+2, 0));\n    vector<vector<int>> vert(n+2, vector<int>(m+2, 0));\n\n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= m;j++){\n            hori[i][j] = hori[i][j-1];\n            vert[i][j] = vert[i-1][j];\n\n            if(arr[i][j]){\n                hori[i][j] += arr[i][j-1]?0:1;\n                vert[i][j] += arr[i-1][j]?0:1;\n            }\n        }\n    }\n\n    for(int i = 0;i < q;i++){\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        long long ans = 0;\n\n        ans = arr[x1][y1];\n\n        ans += hori[x1][y2] - hori[x1][y1];\n        ans += vert[x2][y1] - vert[x1][y1];\n\n        cout << ans + pref[x2][y2] - pref[x2][y1] - pref[x1][y2] + pref[x1][y1] << endl;\n        // remove the -1's as we need the mergnings belowe it and no the ones we are already looking at \n        // fout << pref[x2][y2] - pref[x2][y1-1] - pref[x1-1][y2] + pref[x1-1][y1-1];\n    }\n\n    return 0;\n}",
  "misc/paintbarn/paintbarn.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dimension = 1003;\n\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    ifstream fin(\"paintbarn.in\");\n    ofstream fout(\"paintbarn.out\");\n\n    int n, k;\n\n    fin >> n >> k;\n\n    vector<vector<int>> arr(dimension, vector<int> (dimension, 0));\n    for(int i = 1;i <= n;i++){\n        int a, b, c, d;\n        fin >> a >> b >> c >> d;\n        a++;b++;c++;d++;\n        arr[a][b]++;\n        arr[a][d]--;\n        arr[c][d]++;\n        arr[c][b]--;\n    }\n    long long ans = 0;\n    // for(int i = 0;i < dimension;i++){\n    //     for(int j = 0;j < dimension;j++){\n    //         fout << arr[i][j] << ' ';\n    //     }\n    //     fout << endl;\n    // }\n    // fout <<endl;\n\n    // make sure to not miss the 0's in the coordinates thats why the if statesments\n    // or just increment the things in the starts\n    for(int i=0; i < dimension;i++){\n        for(int j = 0; j < dimension;j++){\n            if(i>0) arr[i][j] += arr[i-1][j];\n            if(j>0) arr[i][j] += arr[i][j-1];\n            if(i>0 && j> 0) arr[i][j] -= arr[i-1][j-1];\n            // arr[i][j] += arr[i-1][j] + arr[i][j-1] - arr[i-1][j-1];\n            if(arr[i][j] == k) ans++;\n        }\n    }\n    // for(int i = 0;i < dimension;i++){\n    //     for(int j = 0;j < dimension;j++){\n    //         fout << arr[i][j] << ' ';\n    //     }\n    //     fout << endl;\n    // }\n    fout << ans;\n\n    return 0;\n}",
  "misc/paintbarn/paintbarn.in": "3 2\n1 1 5 5\n4 4 7 6\n3 3 8 7",
  "misc/paintbarn/paintbarn.out": "0 0 0 0 0 0 0 0 0 0 \n0 1 0 0 0 -1 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 \n0 0 0 1 0 0 0 -1 0 0 \n0 0 0 0 1 0 -1 0 0 0 \n0 -1 0 0 0 1 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 \n0 0 0 0 -1 0 1 0 0 0 \n0 0 0 -1 0 0 0 1 0 0 \n0 0 0 0 0 0 0 0 0 0 \n\n\n0 0 0 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 \n0 0 1 1 1 1 0 0 0 0 \n0 0 1 1 1 1 0 0 0 0 \n0 0 1 1 2 2 1 1 0 0 \n0 0 1 1 2 3 2 1 0 0 \n0 0 0 0 1 2 2 1 0 0 \n0 0 0 0 1 2 2 1 0 0 \n0 0 0 0 1 1 1 1 0 0 \n0 0 0 0 0 0 0 0 0 0 \n\n0 0 0 0 0 0 0 0 0 0 \n0 1 1 1 1 0 0 0 0 0 \n0 1 1 1 1 0 0 0 0 0 \n0 1 1 2 2 1 1 0 0 0 \n0 1 1 2 3 2 1 0 0 0 \n0 0 0 1 2 2 1 0 0 0 \n0 0 0 1 2 2 1 0 0 0 \n0 0 0 1 1 1 1 0 0 0 \n0 0 0 0 0 0 0 0 0 0 \n0 0 0 0 0 0 0 0 0 0 \n8",
  "misc/pairup/pairup.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    ifstream fin(\"pairup.in\");\n    ofstream fout(\"pairup.out\");\n\n    long long n;\n    fin >> n;\n    map<long long , long long> m;\n    for(int i = 0;i < n;i++){\n        long long freq, out;\n        fin >> freq >> out;\n        m[out] += freq;\n    }\n\n    map<long long, long long>::iterator left = m.begin();\n    map<long long, long long>::iterator right = m.end();\n\n    right--;\n\n    long long ans = 0;\n\n    while(left != m.end() && right != m.end() && right->first >= left->first){\n        if(right -> second > left -> second){\n            right -> second -= left->second;\n            left->second = 0;\n        }\n        else{\n            left->second -= right->second;\n            right->second = 0;\n        }\n\n        // long long minn = min(left->second, right->second);\n\n        ans = max(ans, right->first + left->first);\n\n        // right -> second -= minn;\n        // left->second -= minn;\n\n        if(!(left->second)){\n            left++;\n        }\n        if((!(right->second))&& left != right){\n            right--;\n        }\n        if (left == right && left->second == 0) break;\n    }\n\n    fout << ans << endl;\n    return 0;\n}",
  "misc/pairup/pairup.in": "3\n1 8\n2 5\n1 2",
  "misc/pairup/pairup.out": "10\n",
  "misc/permutator.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    \n    return 0;   \n}",
  "misc/rank_acml_checkgoodsolagain.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing vvi = vector<vector<int>>;\nusing vb = vector<bool>;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\nset<int> ans;\n\nvoid dfs(int node, vvi &adj, int curr, vb & vis){ \n    vis[node] = true;\n    if(node == curr){\n        ans.insert(node);\n        return;\n    }\n    for(int child: adj[node]){\n        if(!vis[child]){\n            dfs(child, adj, curr, vis);\n        }\n    }\n}\n\nint main() {\n    setIO();\n\n    int n, k;\n\n    cin >> n >> k;\n\n    vvi adj(n+1);\n\n    for(int i = 0;i < k;i++){\n        int u, v, su, sv;\n        cin >> u >> v>> su >> sv;\n        if(su > sv){\n            adj[u].push_back(v);\n        }\n        else adj[v].push_back(u);\n    }\n\n    for(int i = 1;i <= n;i++){\n        // for(int o = 0;o <=n;o++) vis[i] = 0;\n        vb vis(n+1, false);\n        for(int j: adj[i]) dfs(j, adj, i, vis);\n    }\n\n    cout << ans.size();\n\n    return 0;\n}\n\n\n/*\n// good solution do later again\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (!name.empty()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nvector<int> adj[10001];\nvector<int> disc, low, inStack;\nstack<int> st;\nset<int> result;\nint timer;\n\nvoid tarjanSCC(int u) {\n    disc[u] = low[u] = ++timer;\n    st.push(u);\n    inStack[u] = true;\n\n    for (int v : adj[u]) {\n        if (disc[v] == -1) {\n            tarjanSCC(v);\n            low[u] = min(low[u], low[v]);\n        } else if (inStack[v]) {\n            low[u] = min(low[u], disc[v]);\n        }\n    }\n\n    if (low[u] == disc[u]) {\n        vector<int> scc;\n        while (true) {\n            int v = st.top();\n            st.pop();\n            inStack[v] = false;\n            scc.push_back(v);\n            if (u == v) break;\n        }\n        if (scc.size() > 1) {\n            for (int player : scc) {\n                result.insert(player);\n            }\n        }\n    }\n}\n\nint main() {\n    setIO();\n\n    int n, k;\n    cin >> n >> k;\n\n    for (int i = 0; i < k; i++) {\n        int u, v, su, sv;\n        cin >> u >> v >> su >> sv;\n        if (su > sv) {\n            adj[u].push_back(v);\n        } else {\n            adj[v].push_back(u);\n        }\n    }\n\n    disc.assign(n + 1, -1);\n    low.assign(n + 1, -1);\n    inStack.assign(n + 1, false);\n    timer = 0;\n\n    for (int i = 1; i <= n; i++) {\n        if (disc[i] == -1) {\n            tarjanSCC(i);\n        }\n    }\n\n    cout << result.size() << endl;\n\n    return 0;\n}\n\n*/",
  "misc/running_miles.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int t;\n    cin >> t;\n    while(t--){\n        int n;\n        cin >> n;\n        vector<int> arr(n+1); // for bi2\n        for(int i=0;i < n;i++) cin >> arr[i+1];\n        vector<int> pmax(n+1); // for bi1, prefix max\n        vector<int> smax(n+1); // for bi3, suffix max\n\n        for(int i = 1;i <= n;i++){\n            pmax[i] = arr[i] + i; // for +l in the term -(r-l)\n            smax[i] = arr[i] - i; // for -r in the term -(r-l)\n        }\n\n        int ans = INT_MIN;\n\n        for(int i = 2;i <= n;i++) pmax[i] = max(pmax[i], pmax[i-1]);\n        for(int i = n-1;i >= 1;i--) smax[i] = max(smax[i], smax[i+1]);\n\n        for(int i = 1;i <=n-1;i++){\n            ans = max(ans, pmax[i-1] + arr[i] + smax[i+1]);\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}",
  "misc/solve_maze.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nvector<vector<char>> arr;\nvector<vector<int>> vis;\nvector<pii> paths = {{0, 1},{1, 0},{-1, 0},{0, -1}};\nint n, m;\n\nbool check(int x, int y){\n    return !(x >= n || y >= m || x < 0 || y < 0);\n}\n\nvoid dfs(int i, int j){\n    if(vis[i][j] || arr[i][j] == '#'  || !check(i, j)) return;\n    vis[i][j] = 1;\n    for(auto [cx, cy] : paths){\n        int nx , ny;\n        nx = i + cx;\n        ny = j + cy;\n        if(!check(nx, ny)) continue;\n        dfs(nx, ny);\n    }\n}\n\nvoid solve(){\n    cin >> n >>  m;\n    arr.assign(n, vector<char> (m));\n    vis.assign(n, vector<int> (m, 0));\n\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j < m;j++){\n            cin >> arr[i][j];\n        }\n    }\n\n    // if there is a bad guy right next to a good guy then its impossible to make such a grid\n\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j < m;j++){\n            if(arr[i][j] == 'B'){\n                for(auto [cx, cy] : paths){\n                    int nx , ny;\n                    nx = i + cx;\n                    ny = j + cy;\n                    if(!check(nx, ny)) continue;\n                    if(arr[nx][ny] == 'G'){\n                        cout << \"NO\\n\";\n                        return;\n                    }\n                    else if(arr[nx][ny] == '.'){\n                        arr[nx][ny] = '#';\n                    }\n                }\n            }\n        }\n    }\n    if (arr[n-1][m-1] != '#') {\n        dfs(n-1, m - 1);\n    }// check from the end where all you can go then go there\n    else{\n        // exit is blocked G means NO\n        for(int i = 0;i < n;i++){\n            for(int j = 0;j < m;j++){\n                if(arr[i][j] == 'G'){\n                    cout << \"NO\\n\";\n                    return;\n                }\n            }\n        }\n        cout << \"YES\\n\";\n        return;\n    }\n\n    for(int i = 0;i < n;i++){\n        for(int j = 0;j < m;j++){\n            if(arr[i][j] == 'G' && !vis[i][j]){\n                cout << \"NO\\n\";\n                return;\n            }\n            if(arr[i][j] == 'B' && vis[i][j]){\n                cout << \"NO\\n\";\n                return;\n            }\n        }\n    }\n\n    cout << \"YES\\n\";\n}\n\nint main() {\n    setIO(\"check/check\");\n\n    int t;\n    cin >> t;\n\n    while(t--){\n        solve();\n    }\n\n    return 0;\n}",
  "misc/somethign.cpp": "// #include <iostream>\n// #include <vector>\n// using namespace std;\n\n// vector<int> findIndices(const vector<int>& arr) {\n//     vector<int> indices;\n//     int n = arr.size();\n\n//     for (int i = 0; i < n; ++i) {\n//         // Handle edge cases for the first and last elements\n//         int left = (i > 0) ? arr[i - 1] : INT_MIN;\n//         int right = (i < n - 1) ? arr[i + 1] : INT_MIN;\n\n//         // Check if the current element is greater than or equal to its neighbors\n//         if (arr[i] >= left && arr[i] >= right) {\n//             indices.push_back(i);\n//         }\n//     }\n\n//     return indices;\n// }\n\n// int main() {\n//     vector<int> arr = {352, 266, 409, 22, 424, 716, 797, 749, 985, 485, 638, 521, 16, 82, 17};\n//     vector<int> indices = findIndices(arr);\n\n//     cout << \"Indices: \";\n//     for (int index : indices) {\n//         cout << index << \" \";\n//     }\n//     cout << endl;\n\n//     return 0;\n// }\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n// long long countValidSubsegments(int x, const vector<int>& arr) {\n//     int n = arr.size();\n//     long long count = 0;\n//     int g = 0;\n//     int start = 0;\n\n//     for (int end = 0; end < n; ++end) {\n//         g += arr[end];\n//         while (g > x) {\n//             g -= arr[start];\n//             start++;\n//         }\n//         count += (end - start + 1);\n//     }\n\n//     return count;\n// }\n\nlong long countValidSubsegments(int x, const vector<int>& arr) {\n    int n = arr.size();\n    long long count = 0;\n    int g = 0;\n    int start = 0;\n\n    for (int end = 0; end < n; ++end) {\n        g += arr[end];\n        while (g > x) {\n            g -= arr[start];\n            start++;\n        }\n        if (g != 0) {\n            count += (end - start + 1);\n        }\n    }\n\n    return count;\n}\n\nint main(){\n    vector<int> some = {1, 1, 1, 1};\n    cout << countValidSubsegments(2, some) << endl; \n\n    return 0;\n}",
  "misc/studying_algos.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n\n    int n, x;\n\n    cin >> n >> x;\n    vector<int> arr(n);\n\n    for(int i = 0;i < n;i++){\n        cin >> arr[i];\n    }\n\n    sort(arr.begin(), arr.end());\n\n    int suma = 0;\n    int ans = 0;\n    for(int i = 0;i < n && suma + arr[i]<= x;i++){\n        suma += arr[i];\n        ans++;\n    }\n\n    cout << ans;\n\n    return 0;\n}\n",
  "misc/test.out": "0 0 0 0 0 0 \n0 1 1 1 2 0 \n0 1 1 1 2 0 \n0 2 1 1 3 0 \n0 0 0 0 0 0 \n3201",
  "misc/the_party_and_sweets.cpp": "#include <algorithm>\n#include<bits/stdc++.h>\n#include <functional>\n#include <vector>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n    int n, m;\n    cin >> n >> m;\n    vector<int> bi(n);\n    vector<int> gj(m);\n    for(int i = 0;i < n;i++) cin >> bi[i];\n    for(int j = 0;j < m;j++) cin >> gj[j];\n\n    // I dont think that there is need of an extra array for other stuff like checking is minimal has been reached\n\n\n\n    long long ans = 0;\n\n    sort(gj.begin(), gj.end());\n    sort(bi.begin(), bi.end());\n    // sum excluding the max which would only be included in the end\n    if(gj[0] < bi[n-1]){\n        cout << -1;\n        return 0;\n    }\n    long long suma = 0;\n\n    for(int i = 0;i < n;i++){\n        suma += bi[i];\n    }\n    ans += suma*m; // baseline\n\n    for(int i = 1;i < m;i++){\n        ans += gj[i] - bi[n-1];\n    }\n    // in c++ 20 bi[n-2] is 0 by default I think atleast\n    if(gj[0] != bi[n-1]) ans += gj[0]-bi[n-2]; // if its equal then use the max there no issues which would be 0 again\n    // else use the minimal value of the max\n    cout << ans;\n\n    return 0;\n}\n",
  "misc/they_are_every.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nbool check(map<char, int> &m1, map<char, int> &m2){\n    for(auto const&[val, freq] : m1){\n        if(!m2[val]) return false;\n    }\n    return true;\n}\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    string s;\n    cin >> n;\n    cin >> s;\n\n    map<char, int> m1;\n    map<char, int> m2;\n\n    for(char c : s) m1[c]++;\n\n    int left = 0;\n    int right = 0;\n\n    int dst = m1.size();\n\n    int ans = INT_MAX;\n    \n    // while(right < n){\n    //     while(right < n && !check(m1, m2)){\n    //         m2[s[right]]++;\n    //         right++;\n    //     }\n    //     ans = min(ans, right - left);\n    //     m2[s[left]]--;\n    //     if(!m2[s[left]]){\n    //         m2.erase(s[left]);\n    //     }\n    //     if(left < right) left++;\n    //     // left++;\n    // }\n\n    while(right < n){\n        m2[s[right]]++;\n        right++;\n\n        // here we had to think that we increase the value of right like expand the window everytime but contract when we need it only like when we satisfy the coondition then we check if we can do it.\n\n        while(m2.size() == dst){\n            ans = min(ans, right - left);\n            m2[s[left]]--;\n            if(!m2[s[left]]) m2.erase(s[left]);\n            left++;\n        }\n    }\n\n    cout << ans << endl;\n    return 0;\n}",
  "misc/union_find.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nclass DSU {\n    public:\n    vector<int> parent;\n    vector<int> size;\n\n    DSU(int n) {\n        parent.resize(n+1, 0);\n        size.resize(n+1, 1);\n\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int findPar(int node) {\n        if (parent[node] == node) return node;\n        return parent[node] = findPar(parent[node]); // Path compression\n    }\n\n    void uniteSize(int n1, int n2) {\n        int u, v;\n        u = findPar(n1);\n        v = findPar(n2);\n        if (u == v) return;\n        if (size[u] < size[v]) {\n            parent[u] = v;\n            size[v] += size[u];\n        } else {\n            parent[v] = u;\n            size[u] += size[v];\n        }\n    }\n};\n\nint main() {\n    // setIO(\"check\");\n\n    int n, q;\n    cin >> n >>q;\n\n    DSU ds = DSU(n);\n\n    for(int i = 0;i < q;i++){\n        vector<int> aa(3);\n        cin >> aa[0] >> aa[1] >> aa[2];\n\n        if(!aa[0]){\n            ds.uniteSize(aa[1], aa[2]);\n        }\n        else{\n            cout << (ds.findPar(aa[1])==ds.findPar(aa[2])) << '\\n';\n        }\n    }\n\n    return 0;\n}\n",
  "misc/usaco/range_sum.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int n, q;\n    cin >> n >> q;\n    vector<long> arr(n);\n    for(int i=0;i < n;i++){\n        cin >> arr[i];\n    }\n\n    for(int i=1;i < n;i++){\n        arr[i] = arr[i]+arr[i-1];\n    }\n\n    vector<long> ans(q);\n\n    for(int i=0;i < q;i++){\n        int l, r;\n        cin >> l >> r;\n        ans[i] = (l > 0)?(arr[r-1] - arr[l-1]): arr[r-1];\n    }\n\n    for(long i: ans) cout << i << endl;\n    return 0;\n}",
  "misc/where_am_i/where_am_i.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    ifstream fin(\"whereami.in\");\n    ofstream fout(\"whereami.out\");\n    int n;\n    string s;\n    fin >> n >> s;\n\n    for(int i=0;i < n;i++){\n        unordered_map<string, int> m;\n        // all the substring lengths\n        bool flag = true;\n        for(int j = 0;j < n - i;j++){\n            string s1 = s.substr(j, i+1);\n            m[s1]++;\n            if(m[s1] > 1){\n                flag = false;\n                break;\n            }\n        }\n        if(flag){\n            fout << i+1;\n            return 0;\n        }\n    }\n    return 0;\n}",
  "misc/where_am_i/whereami.in": "7\nABCDABC",
  "misc/where_am_i/whereami.out": "4",
  "misc/wormhole/wormhole.cpp": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    setIO();\n\n    \n\n    return 0;\n}",
  "problem_sets/.vscode/settings.json": "{\n    \"files.associations\": {\n        \"iostream\": \"cpp\"\n    },\n    \"C_Cpp.errorSquiggles\": \"enabled\"\n}",
  "problem_sets/MissingNumber": null,
  "problem_sets/MissingNumber.cpp": "#include<iostream>\nusing namespace std;\n\nvoid swap(int *x, int *y){\n    int temp = *x;\n    *x=*y;\n    *y=temp;\n}\n\nint main(){\n    int n,j,i;\n    cin>>n;\n    int arr[n];\n    for( i=0;i<n-1;i++) cin>>arr[i];\n    for(i=0;i<n-1;i++){\n        for(j=i;j<n-1;j++) if(arr[j]<arr[i]) swap(&arr[j],&arr[i]);\n    }\n    for (i=0;i<n-1;i++) if (arr[i]!=i+1){\n        cout<<i+1;\n        break;\n    }\n    return 0;\n}",
  "problem_sets/WeirdAlgorithm": null,
  "problem_sets/WeirdAlgorithm.cpp": "#include<iostream>\nusing namespace std;\nlong long int recursion(long long int n){\n    if (n==1) return 1;\n    else if(n>0 && n%2==0){\n        cout<<n/2<<\" \";\n        return recursion(n/2);\n    }\n    else {\n        cout<<3*n+1<<\" \";\n        return recursion(3*n+1);\n    }\n}\n\nint main(){\n    long long int n;\n    cin>>n;\n    cout << n<< \" \";\n    recursion(n);\n    return 0;\n}\n",
  "problem_sets/ansh": null,
  "problem_sets/ansh.c": "# include<stdio.h>\n\ttypedef struct address{\n\t\tint houseno;\n\t\tint block;\n\t\tchar city[50];\n\t\tchar state[50];\n\t}add;\n\tint main(){\n\t\tadd op[5];\n\t\tfor(int i=0;i<5;i++){\n\t\t\tprintf(\"enter the house number \");\n\t\t\tscanf(\"%d\",&op[i].houseno);\n\t\t\tprintf(\"enter the block\");\n\t\t\tscanf(\"%d\",&op[i].block);\n\t\t\tprintf(\"enter the city \");\n\t\t\tscanf(\" %[^\\n]s\",op[i].city);\n\t\t\tprintf(\"enter the state\");\n\t\t\tscanf(\" %[^\\n]s\",op[i].state);\n\t\t}\n        return 0;\n\n\t}",
  "problem_sets/compare_strings": null,
  "problem_sets/compare_strings.c": "#include<stdio.h>\n#include<string.h>\n\nint min(int a,int b){\n    if(a>b) return b;\n    else return a;\n}\n\n\nint max(int a,int b){\n    if(a>b) return a;\n    else return b;\n}\n\nint main(){\n    char a[100],b[100];\n    gets(a);\n    gets(b);\n    char c[100], d[100], e[100];\n    int i,l1,l2,j;\n    for(i=0;a[i]!='\\0';i++);\n    l1=i;\n    for(i=0;b[i]!='\\0';i++);\n    l2=i;\n    int maxi= max(l1,l2);\n    for(i=0;i<maxi;i++){\n        if(a[i]==b[i]) c[i]= a[i];\n    }\n    puts(c);\n    i=0;\n    while(i<maxi){\n        if(c[i]!=b[i]) printf(\"%c\",b[i]);\n        i++;\n    }\n    printf(\"\\n\");\n    i=0;\n    while(i<maxi){\n        if(c[i]!=a[i]) printf(\"%c\",a[i]);\n        i++;\n    }\n    return 0;    \n}\n",
  "problem_sets/cricket.c": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct cricket {\n  char player_name[20];\n  char team_name[20];\n  float batting_avg;\n} cricketer;\n\n\n\nint main(void) {\n  int i = 0, j = 0, n = 10;\n    cricketer player[50];\n  for (i = 0; i < n; i++) {\n    printf(\"\\n Enter Player Name : \");\n    scanf(\"%s\", player[i].player_name);\n    printf(\"\\n Enter Team Name : \");\n    scanf(\"%s\", player[i].team_name);\n    printf(\"\\n Enter Batting Average : \");\n    scanf(\"%f\", & player[i].batting_avg);\n  }\n\n  return 0;\n}\n\n",
  "problem_sets/doc.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n;\n    cin >> n;\n    unordered_set<int> s;\n    for(int i=0;i < n-1;i++){\n        int val;\n        cin >> val;\n        s.insert(val);\n    }\n\n    for(int i=1;i <= n;i++){\n        if(s.find(i) == s.end()){\n            cout << i <<endl;\n            return 1;\n        }\n    }\n    return 0;\n}",
  "problem_sets/findmedian.c": "double findMedianSortedArrays(int* nums1, int nums1Size, int* nums2, int nums2Size) {\n    long long n_check= nums2[0];\n    long long s=0,l,mid,index;\n    l=nums1Size;\n    mid =(s+l)/2;\n    while(l>=s){\n        if(nums1[mid]>n_check) l=mid-1;\n        else if (nums1[mid]<n_check) s=mid+1;\n        else{\n            index= mid;\n            break;\n        }\n        mid = (s+l)/2;\n    }\n    \n    for(long long i=nums1Size;i>index;i++){\n        \n    }\n\n    if ((nums1Size+nums2Size)%2==0) return(nums1[(nums1Size+nums2Size)/2-1]+nums1[(nums1Size+nums2Size)/2]);\n    else return(nums1[nums1Size+nums2Size]);\n}",
  "problem_sets/increasingarray.cpp": "#include<iostream>\nusing namespace std;\nint main(){\n    long long count=0;\n    long long n;\n    cin>>n;\n    int arr[n];\n    for(long long i=0;i<n;i++) cin>>arr[i];\n    for(long long i=1;i<n;i++){\n        while(arr[i]<=arr[i-1]){\n            arr[i]++;\n            count++;\n        }\n    }\n    cout<<count<<endl;\n    return 0;\n}",
  "problem_sets/questions": null,
  "problem_sets/questions.c": "// #include<stdio.h>\n\n// void swap(int *x, int *y){\n//     int temp= *x;\n//     *x=*y;\n//     *y=temp;\n// }\n\n// int main(){\n//     int i, n, j;\n//     scanf(\"%d\",&n);\n//     int arr[n];\n//     for(i=0;i<n;i++) scanf(\"%d\",&arr[i]);\n//     for(i=0;i<n;i++){\n//         for(j=i;j<n;j++) if(arr[i]>arr[j]) swap(&arr[i],&arr[j]);\n//         // Ascending, Reverse for descending\n//     }\n//     // for(i=0;i<n;i++) printf(\"%d\\t\",arr[i]);\n//     int key;\n//     scanf(\"%d\",&key);\n//     printf(\"%d\", arr[n-key]);\n//     return 0;\n// }\n\n#include<stdio.h>\n#include<stdbool.h>\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int arr[n];\n    for(int i=0;i<n;i++) scanf(\"%d\",&arr[i]);\n    int uniq[n],i=0,j=0,c=0;\n    bool flag=false;\n    for(i=0;i<n;i++){\n        flag=false;\n        for(j=0;j<n;j++){// j=i otherwise &&\n        if(arr[i]==arr[j]&&i!=j) flag=true;\n        }\n        if(!flag){\n            uniq[c]=arr[i];\n            c++;\n        }\n    }\n\n    for(i=0;i<c;i++){\n        printf(\"%d \",uniq[i]);\n    }\n\n    return 0;\n}\n\n// #include<stdio.h>\n\n// int main(){\n//     int n;\n//     scanf(\"%d\",&n);\n//     int arr[n];\n//     for(int i=0;i<n;i++) scanf(\"%d\",&arr[i]);\n//     int frequency[10000],i,j,c=0;// char\n//     for(i=0;i<10000;i++) frequency[i]=0;\n//     for(i=0;i<n;i++){\n//         c=0;\n//         for(j=0;j<n;j++){\n//             if(arr[i]==arr[j]) c++;\n//         }\n//         frequency[arr[i]]=c;\n//     }\n//     for(i=0;i<10000;i++){\n//         if(frequency[i]!=0) printf(\"%d occurs %d times\\n\",i,frequency[i]);\n//     }\n//     return 0;\n// }\n\n",
  "problem_sets/repitition.cpp": "#include<iostream>\n#include<string>\nusing namespace  std;\nint main(){\n    long long streak=0,temp=0;\n    string str;\n    cin>>str;// otherwise getline() function is to be used\n\n    for(long long i=0;i<str.size()-1;i++){\n        for(long long j=i;j<str.size();j++){\n            if(str[i]==str[j]){\n                    temp++;\n                    streak=max(temp,streak);\n                }\n            else{\n                    temp=0;\n                    break;\n                }\n        }\n    }\n    cout<<streak<<endl;\n    return 0;\n}\n\nlong long max(long long a,long long b){\n    long long maxi=INT16_MIN;\n    if(a>b) maxi=a;\n    else maxi= b;\n    return maxi;\n}",
  "problem_sets/something_new": null,
  "problem_sets/something_new.c": "// // // #include<stdio.h>\n// // // #include<math.h>\n// // // #include<string.h>\n\n\n// // #include<stdio.h>\n// // #include<stdlib.h>\n\n// // int main()\n// // {\n// // \tint *p,i;\n// // \tp = (int*)calloc(1,sizeof(int));// starting of Dynamic Array\n// // \tfor(i=0;i<3;i++)\n// // \t{\n// // \t\tp[i]= i;\n// // \t\tp = realloc(p,(i+1)*sizeof(int));\n\t\t\n// // \t}\n// // \tfor(i=0;i<3;i++)\n// // \t{\n// // \t\t//printf(\"%d\\n\",*(p+i));\n// // \t\tprintf(\"%d\\n\",p[i]);\n// // \t}\n// //     return 0;\n// // }\n\n// #include<stdio.h>\n// // #include<malloc.h>\n// #include<stdlib.h>\n// int main(){\n//     int arr[3]={1,2,3};\n//     int i;\n//     int *p= (int*)calloc(1,sizeof(int));\n//     for(i=0 ; i<5 ; i++){\n//         p=realloc(p, (i+1)*sizeof(int));\n//         *(p+i)=i+1;\n        \n//     }\n//     for(i=0 ; i<5 ; i++){\n//         printf(\"%d \",*(p+i));\n//     }\n//    free(p);// frees the entire block of code.\n//     for(i=0 ; i<5 ; i++){\n//         printf(\"%d \",*(p+i));\n//     }\n    \n//     return 0;\n// }\n# include<stdio.h>\nint main(){\n\tchar str[50];\n\tprintf(\"enter a string\");\n\tgets(str);\n\t// scanf(\"%s\",str);\n\tint count=0;\n\tint i=0;\n\twhile(str[i]!='\\0'){\n\t\tcount++;\n\t\ti++;\n\t}\n\tprintf(\"the length of the string is %d\",count);\n\treturn 0;\n}",
  "problem_sets/strings": null,
  "problem_sets/strings.c": "#include<stdio.h>\n#include <stdbool.h>\n#include<math.h>\n\n\nvoid count_words(){\n    int i,c;\n    char abc[100];\n    gets(abc);\n    for(i=0;abc[i]!='\\0';i++){\n        if(abc[i]==' ')c++;\n    }\n    printf(\"%d\",c+1);\n}\n\nvoid compare(){\n    char s1[100],s2[100];\n    int i;\n    bool flag=true;\n    gets(s1);\n    gets(s2);\n    for(i=0;s1[i]!='\\0'&&s2[i]!='\\0';i++){\n        if(s1[i]!=s2[i]) flag= false;\n    }\n    if(!flag) printf(\"Not equal\");\n    else printf(\"Equal\");\n}\n\nvoid count_all(){\n    char s[100];\n    int i;\n    int frequency[256]={0};\n    for(i=0;i<256;i++) frequency[i]=0;\n\n    gets(s);\n    \n    for(i=0;s[i]!='\\0';i++) frequency[s[i]]++;\n    // store at s[i] which is the value at which is the ASCII Code\n    for(i=0;i<256;i++) if(frequency[i]!=0) printf(\"%c has occurred %d times.\\n\",i,frequency[i]);\n}\n\nvoid sort_2powern(){\n    int n,f;\n    scanf(\"%d\",&n);\n    int arr[n];\n    for(int i=0;i<n;i++) scanf(\"%d\",&arr[i]);\n    for(int i=0;i<n;i++){\n        for(int j=2;j<=arr[n];j++){\n            while(arr[i]%i==0){\n                arr[i]=arr[i]/j;\n                f=i;\n                if(f!=2) printf(\"%d \",arr[i]);\n            }\n        }\n    }\n}\n\nint main(){\n\n    // count_words();\n    // compare();\n    // count_all();\n    // sort_2powern();\n    return 0;\n}\n",
  "problem_sets/tests.zip": null,
  "question.cpp": "// #include<bits/stdc++.h>\n// using namespace std;\n// using vi = vector<int>;\n// using vvi = vector<vector<int>>;\n// using pii = pair<int, int>;\n\n// void setIO(string name = \"\") {\n//     ios_base::sync_with_stdio(0);\n//     cin.tie(0);\n//     if (name.size()) {\n//         freopen((name + \".in\").c_str(), \"r\", stdin);\n//         freopen((name + \".out\").c_str(), \"w\", stdout);\n//     }\n// }\n\n// vector<pii> changes = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n\n// bool check(int i, int j, int n){\n//     return !(i >= n || j>= n|| i< 0 || j < 0);\n// }\n\n// void dfs(int i, int j,vvi & grid, vvi &visited){\n//     int n = grid.size();\n//     visited[i][j] = 1;\n//     for(auto const&[xv, xy] : changes){\n//         int nx = xv + i;\n//         int ny = xy + j;\n\n//         if(check(nx, ny, n) && !visited[nx][ny] && grid[nx][ny] == 1){\n//             dfs(nx, ny, grid, visited);\n//         }\n//     }\n// }\n\n// int solve(vvi &grid1, vvi&grid2){\n//     int n = grid1.size();\n\n//     for(int i = 0;i < n;i++){\n//         for(int j = 0;j < n;j++){\n\n//         }\n//     }\n// }\n\n// int main() {\n//     setIO();\n\n\n\n//     return 0;\n// }\n\n#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint rows, cols;\n\nvector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nvoid dfs(vector<vector<int>> &grid, int x, int y, set<pair<int, int>> &region, int baseX, int baseY) {\n    if (x < 0 || y < 0 || x >= rows || y >= cols || grid[x][y] == 0)\n        return;\n\n    grid[x][y] = 0;\n\n    region.insert({x - baseX, y - baseY});\n\n    for (auto &[dx, dy] : directions) {\n        dfs(grid, x + dx, y + dy, region, baseX, baseY);\n    }\n}\n\nvector<set<pair<int, int>>> findRegions(vector<vector<int>> &grid) {\n    vector<set<pair<int, int>>> regions;\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == 1) {\n                set<pair<int, int>> region;\n                dfs(grid, i, j, region, i, j);\n                regions.push_back(region);\n            }\n        }\n    }\n    return regions;\n}\n\nint countMatchingRegions(vector<vector<int>> grid1, vector<vector<int>> grid2) {\n    auto regions1 = findRegions(grid1);\n    auto regions2 = findRegions(grid2);\n\n    int matches = 0;\n    for (auto &r1 : regions1) {\n        for (auto &r2 : regions2) {\n            if (r1 == r2) {  \n                matches++;\n                break; \n            }\n        }\n    }\n    return matches;\n}\n\n// Driver Code\nint main() {\n    vector<vector<int>> grid1 = {\n        {1, 1, 1},\n        {1, 0, 0},\n        {1, 0, 0}\n    };\n\n    vector<vector<int>> grid2 = {\n        {1, 1, 1},\n        {1, 0, 0},\n        {1, 0, 1}\n    };\n\n    rows = grid1.size();\n    cols = grid1[0].size();\n\n    cout << \"Matching Regions: \" << countMatchingRegions(grid1, grid2) << endl;\n    return 0;\n}",
  "range_queries/forest_queries.cpp": "// #include<bits/stdc++.h>\n#include<vector>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, q;\n    cin >> n >> q;\n    vector<vector<int>> arr(n+1, vector<int>(n+1, 0));\n\n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= n;j++){\n            char c;\n            cin >> c;\n            if(c == '*'){\n                arr[i][j] = 1;\n            }\n        }\n    }\n\n    for(int i = 1;i <= n;i++){\n        for(int j = 1;j <= n;j++){\n            arr[i][j] = arr[i][j] + arr[i-1][j] + arr[i][j-1] - arr[i-1][j-1];\n        }\n    }\n\n    for(int i = 0;i < q;i++){\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        cout << arr[x2][y2] - arr[x1-1][y2] - arr[x2][y1-1] + arr[x1-1][y1-1] << endl;\n    }\n\n    return 0;\n}",
  "sorting_searching/.sum_of_two_vals.cpp.swp": null,
  "sorting_searching/SubarrayDivisibility.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    for(int i=0;i < n;i++) cin >> arr[i];\n    map<int , int> freq_map;\n    int pref = 0;\n    long long ans = 0;\n    freq_map[0] = 1;// basically base case whenever the value is 0 add this\n    for(int i=0;i < n;i++){\n        pref += arr[i];\n        int modvalue = (n + pref)%n;// be careful about thihs line\n        if(modvalue < 0) modvalue += n;\n        ans += freq_map[modvalue];\n        freq_map[modvalue]++;\n        pref = modvalue;\n    }\n    cout << ans << endl;\n    return 0;\n}",
  "sorting_searching/SubarraySumsII.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nint main()\n{\n    int n, x;\n    cin >> n >> x;\n    vector<int> arr(n);\n    for(int i=0;i < n;i++){\n        cin >> arr[i];\n    }\n    // unordered_map<long long, int> freq_map; // unordered mapp would not work because of collisions\n    map<long long, int> freq_map;\n    freq_map[0] = 1; // empty subarray sum basically\n    long long suma = 0; // prefix sum\n    long long ans = 0;\n    for(int i=0;i < n;i++){\n        suma += arr[i];\n\n        ans += freq_map[suma - x];\n\n        freq_map[suma]++;\n    }\n    cout << ans << endl;\n    return 0;\n}",
  "sorting_searching/array_division.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\n\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nbool num_subarray_valid(vi &arr, ll max_suma, const int &k){\n    // the subarrays should all be less than or equal to the max_suma\n\n    int num_subarray = 0;\n    ll rolling_sum = 0;\n\n    for(int &i: arr){\n        if(i > max_suma) return false;\n        if(rolling_sum + i > max_suma){\n            num_subarray++;\n            rolling_sum = 0;\n        }\n\n        rolling_sum += i;\n    }\n\n    if(rolling_sum) num_subarray++;\n\n    return num_subarray <= k;\n}\n\nint main() {\n    // setIO(\"check\");\n\n    int n, k;\n    cin >> n >> k;\n    vi arr = vi(n, 0);\n    for(int i = 0;i < n;i++) cin >> arr[i];\n\n    ll suma = 0;\n\n    for(int &i : arr){\n        suma += i;\n    }\n\n    ll lo, hi, mid;\n    // even 0 would work\n    lo =0; // max element would be the least suma\n    hi = suma; // start from here\n\n    while(lo < hi){\n        // as mid and mid - 1 so can't keep lo <= hi as it would be infinite loop\n\n        mid = lo + (hi - lo)/2;\n\n        if(num_subarray_valid(arr, mid, k)){\n            // this means that we were able to split so decrease it now\n            hi = mid;\n        }\n        else{\n            lo = mid + 1;\n        }\n    }\n    // hi would be equal to lo in the end and lo = mid + 1 in the for more refer to iPad notes practice DSA in sem 4\n    cout << lo;\n\n    return 0;\n}",
  "sorting_searching/check.in": "5 3\n2 4 7 3 5\n",
  "sorting_searching/check.out": "8",
  "sorting_searching/concert_tickets.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<long long> temp(n, 0);\n    for(int i = 0;i < n;i++){\n        cin >> temp[i];\n    }\n    map<long long, long long> s;\n\n    for(int i = 0;i < n;i++){\n        s[temp[i]]++;\n    }\n\n    vector<long long> arr(m, 0);\n    for(int i = 0;i < m;i++){\n        cin >> arr[i];\n    }\n\n    for(int i = 0;i < m;i++){\n        int val = arr[i];\n        if(s.empty()){cout <<\"-1\\n\"; continue;}\n        auto maxx = s.upper_bound(val);\n\n        if(maxx == s.begin()){\n            cout << \"-1\\n\";\n        }\n        else{\n            maxx--;\n            cout << (maxx->first) << '\\n';\n            s[maxx->first]--;\n            if(!s[maxx->first]) s.erase(maxx);\n        }\n    }\n    return 0;\n}",
  "sorting_searching/distinct_number.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\n#include <unordered_set>\nusing namespace std;\nint main()\n{\n    ios :: sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    if(n == 1){\n        cout << 1 << endl;\n        return 0;\n    }\n    vector<int> ans(n);\n    for(int i=0;i < n;i++){\n        cin >> ans[i];\n    }\n    sort(ans.begin(), ans.end());\n    int node = 1;\n    for(int i=1; i < n;i++){\n        if(ans[i]!= ans[i-1]){\n            node++;\n        }\n    }\n    cout << node << endl;\n    return 0;\n}",
  "sorting_searching/factory_machines.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nll most(vi &arr, ll t, ll maxx){\n    ll ans = 0;\n    for(int i = 0;i < arr.size();i++){\n        ans += (t/(arr[i]));\n        // this line is important to prevent overflow and bad /unexpected output\n        if(ans >= maxx) return ans;\n    }\n    return ans;\n}\n\nint main() {\n    // setIO(\"check\");\n    ll n, t;\n\n    cin >> n >> t;\n\n    vi arr = vi(n);\n    sort(all(arr));\n\n    for(int i = 0;i < n;i++) cin >>arr[i];\n    ll minn = arr[0];\n    ll hi = minn * t;\n    ll lo = 0;\n    ll mid = 0;\n    ll ans = LONG_MAX;\n    while(lo <= hi){\n        // here we can keep lo <= hi as there is mid + 1 and mid -1 if there was even one mid instead of them them it would have been an infinite loop which is not good\n        mid = lo +(hi - lo)/2;\n\n        ll some = most(arr, mid, t);\n\n        if(some >= t){\n            ans = min(ans, mid);\n        }\n\n        if(some >= t){\n            hi = mid - 1;\n        }\n        else{\n            lo = mid + 1;\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}",
  "sorting_searching/maximum_subarray_sum.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<long long> arr(n);\n    for(int i=0;i < n;i++){\n        cin >> arr[i];\n    }\n\n    /*\n        Method 1: Kadane's Algorithm\n        O(N) TC\n        O(1) SC\n\n        long long ans = LONG_MIN;\n        long long curr_sum = 0;\n        for(int i=0;i < n;i++){\n            curr_sum += arr[i];\n            ans = max(ans, curr_sum);\n            if(curr_sum < 0) curr_sum = 0;\n        }\n        cout << ans << '\\n';\n    \n    */\n\n    // Method 2 using prefix sums, subtract the smallest subarray sum till now\n\n    long long ans = arr[0];\n\n    for(int i=1;i < n;i++){\n        arr[i] += arr[i-1];\n    }\n\n    long long min_sum = 0;\n\n    for(int i=0;i < n;i++){\n        ans = max(ans, arr[i] - min_sum);// this takes the first number into account as well \n        min_sum = min(arr[i], min_sum); // smallest subaaray till now this line is below in order to prevent unneccessary 0 like minsum == arr[i] in the ans value\n    } \n\n    cout << ans << '\\n';\n\n    return 0;\n}",
  "sorting_searching/movie_fest_2.cpp": "#include<bits/stdc++.h>\n#include <cstdio>\n#include <set>\nusing namespace std;\nusing pii = pair<int, int>;\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n    int n, k;\n    cin >> n >> k;\n    vector<pii> some(n);\n\n    for(int i = 0;i < n;i++){\n        cin >> some[i].second >> some[i].first;\n    }\n    sort(some.begin(), some.end());\n    // always take the one which ends earlier as it would give more options in the future\n    //\n    multiset<int> m;\n    int ans = 0;\n    for(int i = 0;i < n;i++){\n        // it would be optimal to get the vals which are the largest and we can assigne something to them\n        auto it = m.upper_bound(some[i].second);\n        if(it != m.begin()){\n            ans++;\n            it--;\n            m.erase(it);\n            m.insert(some[i].first);\n        }\n        else if(m.size() < k){\n            m.insert(some[i].first);\n            ans++;\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}\n",
  "sorting_searching/movie_festival.cpp": "#include<bits/stdc++.h>\n#include <cstdio>\nusing namespace std;\nusing pii = pair<int, int>;\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n    int n;\n    cin >> n;\n    vector<pii> some(n);\n\n    for(int i = 0;i < n;i++){\n        cin >> some[i].second >> some[i].first;\n    }\n    sort(some.begin(), some.end());\n    // always take the one which ends earlier as it would give more options in the future\n    //\n\n    int ans = 0;\n    int lastDeadline = 0;\n    for(int i = 0;i < n;i++){\n        if(lastDeadline <= some[i].second){\n            lastDeadline = some[i].first;\n            ans++;\n        }\n    }\n\n    cout << ans;\n\n    return 0;\n}\n",
  "sorting_searching/room_allocation.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<int> rooms(n, 0);\n    vector<pii> times(n);\n    for(int i = 0;i < n;i++){\n        cin >> times[i].first;\n        cin >> times[i].second;\n    }\n    sort(times.begin(), times.end());\n\n    multiset<int> m;\n\n    for(int i = 0;i < n;i++){\n        \n    }\n    return 0;\n}",
  "sorting_searching/subarray_sum1.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    long long ans = 0;\n    map<long long, long long> m;\n    m[0] = 1;\n    int n, x;\n    cin >> n >> x;\n    vector<int> arr(n);\n    for(int i = 0;i < n;i++) cin >> arr[i];\n\n    long long suma = 0;\n    for(int i = 0;i < n;i++){\n        suma += arr[i];\n        ans += m[suma - x];\n        m[suma]++;\n    }\n    cout << ans << endl;\n    return 0;\n}",
  "sorting_searching/sum_of_three.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\nint binarySearch(vector<pii> &arr, int low, int high, int x)\n{\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n\n        // Check if x is present at mid\n        if (arr[mid].first == x)\n            return mid;\n\n        // If x greater, ignore left half\n        if (arr[mid].first < x)\n            low = mid + 1;\n\n        // If x is smaller, ignore right half\n        else\n            high = mid - 1;\n    }\n\n    // If we reach here, then element was not present\n    return -1;\n}\n\nint main(){\n    int n, x;\n    cin >> n >> x;\n    vector<pii> arr(n);\n    for(int i = 0;i < n;i++){\n        cin >> arr[i].first;\n        arr[i].second = i;\n    }\n\n    sort(arr.begin(), arr.end());\n\n    for(int i = 0;i < n;i++){\n        for(int j = i+1;j < n;j++){\n            int index = binarySearch(arr, 0, n-1,x - arr[i].first - arr[j].first);\n            if(index != -1 && i != index && j != index){\n                cout << arr[i].second + 1 << ' '<< arr[j].second + 1 << ' '<<arr[index].second + 1 << endl;\n                return 0;\n            }\n        }\n    }\n\n    cout << \"IMPOSSIBLE\" << endl;\n\n    return 0;\n}",
  "sorting_searching/sum_of_two_vals.cpp": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <string>  \n#include <vector>\n#include <list>        \n#include <set> \n#include <map>    \n#include <queue> \n#include <stack>\n#include <algorithm>  \n#include <cmath> \n#include <ctime> \n#include <cstdlib>\n#include <cstring> \n#include <cctype> \n#include <cassert>\n#include <exception>   \n#include <functional>\n#include <iterator>\n#include <limits>  \n#include <locale>   \n#include <numeric>  \n#include <random> \n#include <stdexcept> \n#include <typeinfo> \n#include <utility>\nusing namespace std;\nusing pii = pair<int, int>;\n\nint binarys(int tar, vector<pii> & arr){\n    int low = 0;\n    int n = arr.size();\n    int high = n - 1;\n    int mid;\n    while(low <= high){\n        mid = low + (high - low)/2;\n        if(arr[mid].first == tar){\n            return mid;\n        }\n        else if(arr[mid].first > tar){\n            high = mid - 1;\n        }\n        else{\n            low = mid + 1;\n        }\n    }\n    return -1;\n}\n\nint main()\n{\n    int n, x;\n    cin >> n >> x;\n    vector<pii> arr(n);\n    for(int i=0;i < n;i++){\n        cin >> arr[i].first;\n        arr[i].second = i;\n    }\n    sort(arr.begin(), arr.end());\n\n    for(int i=0;i < n;i++){\n        int search = binarys(x - arr[i].first, arr);\n        if(search != -1 && search != i){\n            cout << arr[i].second + 1<< ' '<< arr[search].second + 1<< \"\\n\";\n            return 0;\n        }\n    }\n\n    cout << \"IMPOSSIBLE\\n\";\n    \n    return 0;\n}",
  "sorting_searching/tasks_dead.cpp": "#include<bits/stdc++.h>\n#include <cstdio>\nusing namespace std;\nusing pii = pair<int, int>;\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n    int n;\n    cin >> n;\n    vector<pii> some(n);\n\n    for(int i = 0;i < n;i++){\n        cin >> some[i].first >> some[i].second;\n    }\n    sort(some.begin(), some.end());\n    // always take the one which ends earlier as it would give more options in the future\n    //\n\n    long long ans = 0;\n    long long currTime = 0;\n    for(int i = 0;i < n;i++){\n        currTime += some[i].first;\n        ans += some[i].second - currTime;\n    }\n\n    cout << ans;\n\n    return 0;\n}\n",
  "sorting_searching/towers.cpp": "#include<bits/stdc++.h>\n#include <set>\nusing namespace std;\n\nvoid setIO(string name = \"\") {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if (name.size()) {\n        freopen((name + \".in\").c_str(), \"r\", stdin);\n        freopen((name + \".out\").c_str(), \"w\", stdout);\n    }\n}\n\nint main() {\n    // setIO(\"check\");\n\n    int n;\n    cin >> n;\n\n    multiset<int> m;\n\n    for(int i = 0;i < n;i++){\n        int val;\n        cin >> val;\n\n        if(m.upper_bound(val) == m.end()){\n            m.insert(val);\n        }\n        else{\n            m.erase(m.upper_bound(val));\n            m.insert(val);\n        }\n    }\n\n    cout << m.size();\n\n    return 0;\n}\n",
  "sorting_searching/traffic_lights.cpp": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int x, n;\n    cin >> x >> n;\n\n    multiset<int> m;\n    m.insert(x);\n\n    set<int> s;\n    s.insert(0);\n    s.insert(x);\n\n    for(int i = 0;i < n;i++){\n        int pos;\n        cin >> pos;\n\n        auto left = s.upper_bound(pos);\n        auto right = left;\n        left--;\n\n        m.erase(m.find((*right) - (*left)));\n        m.insert((*right) - pos);\n        m.insert(pos - (*left));\n        s.insert(pos);\n        cout << *(--m.end()) << ' ';\n    }\n\n    return 0;\n}"
}
